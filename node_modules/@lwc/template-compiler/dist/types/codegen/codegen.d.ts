import { ResolvedConfig } from '../config';
import * as t from '../shared/estree';
import { IRElement, LWCDirectiveRenderMode } from '../shared/types';
export default class CodeGen {
    /** The AST root. */
    readonly root: IRElement;
    /** The template render mode. */
    readonly renderMode: LWCDirectiveRenderMode;
    /** Indicates whether the generated code should preserve HTML comments or not. */
    readonly preserveComments: boolean;
    /**
     * This flag indicates if the generated code should scope the template fragment id. It is set to
     * true if the template also contains ids.
     *
     * TODO [#1150]: Remove this code once we can figure out how to do this in a deterministic
     * fashion.
     */
    readonly scopeFragmentId: boolean;
    currentId: number;
    currentKey: number;
    usedApis: {
        [name: string]: t.Identifier;
    };
    usedSlots: {
        [name: string]: t.Identifier;
    };
    usedLwcApis: Set<string>;
    slotNames: Set<string>;
    memorizedIds: t.Identifier[];
    referencedComponents: Set<string>;
    constructor({ root, config, scopeFragmentId, }: {
        root: IRElement;
        config: ResolvedConfig;
        scopeFragmentId: boolean;
    });
    generateKey(): number;
    genElement(tagName: string, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genCustomElement(tagName: string, componentClass: t.Identifier, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genDynamicElement(tagName: string, ctor: t.Expression, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genText(value: string | t.Expression): t.Expression;
    genComment(value: string): t.Expression;
    genIterator(iterable: t.Expression, callback: t.FunctionExpression): import("estree").CallExpression;
    genBind(handler: t.Expression): import("estree").CallExpression;
    genFlatten(children: t.Expression[]): import("estree").CallExpression;
    genKey(compilerKey: t.SimpleLiteral, value: t.Expression): import("estree").CallExpression;
    genScopedId(id: string | t.Expression): t.CallExpression;
    genScopedFragId(id: string | t.Expression): t.CallExpression;
    getSlot(slotName: string, data: t.ObjectExpression, children: t.Expression): import("estree").CallExpression;
    genTabIndex(children: [t.Expression]): import("estree").CallExpression;
    getMemorizationId(): import("estree").Identifier;
    genBooleanAttributeExpr(bindExpr: t.Expression): import("estree").ConditionalExpression;
    private _genUniqueIdentifier;
    private _toValidIdentifier;
    private _renderApiCall;
}
