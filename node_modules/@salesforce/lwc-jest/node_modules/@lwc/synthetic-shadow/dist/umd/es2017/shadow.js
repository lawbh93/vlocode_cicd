/* proxy-compat-disable */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
    factory();
}(function () { 'use strict';

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { freeze, seal, keys, create, assign, defineProperty, getPrototypeOf, setPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyNames, defineProperties, getOwnPropertySymbols, hasOwnProperty, preventExtensions, isExtensible, } = Object;
    const { concat: ArrayConcat, filter: ArrayFilter, find: ArrayFind, slice: ArraySlice, splice: ArraySplice, unshift: ArrayUnshift, indexOf: ArrayIndexOf, push: ArrayPush, map: ArrayMap, join: ArrayJoin, forEach, reduce: ArrayReduce, reverse: ArrayReverse, } = Array.prototype;
    const { replace: StringReplace, toLowerCase: StringToLowerCase, indexOf: StringIndexOf, charCodeAt: StringCharCodeAt, slice: StringSlice, split: StringSplit, } = String.prototype;
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }
    function isTrue(obj) {
        return obj === true;
    }
    function isFalse(obj) {
        return obj === false;
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    const OtS = {}.toString;
    function toString(obj) {
        if (obj && obj.toString) {
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS.call(obj);
        }
        else {
            return obj + '';
        }
    }
    function getPropertyDescriptor(o, p) {
        do {
            const d = getOwnPropertyDescriptor(o, p);
            if (!isUndefined(d)) {
                return d;
            }
            o = getPrototypeOf(o);
        } while (o !== null);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
    const elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint')
        ? Document.prototype.elementFromPoint
        : Document.prototype.msElementFromPoint; // IE11
    // defaultView can be null when a document has no browsing context. For example, the owner document
    // of a node in a template doesn't have a default view: https://jsfiddle.net/hv9z0q5a/
    const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
    const { createComment, querySelectorAll, getElementById, getElementsByClassName, getElementsByTagName, getElementsByTagNameNS, } = Document.prototype;
    // In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype
    // In all other browsers have the method on Document.prototype
    const { getElementsByName } = HTMLDocument.prototype;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, DOCUMENT_FRAGMENT_NODE, } = Node;
    const { appendChild, cloneNode, compareDocumentPosition, insertBefore, removeChild, replaceChild, } = Node.prototype;
    const parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
    const ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
    const parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement')
        ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get; // IE11
    const textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
    const childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes')
        ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get; // IE11
    const isConnected = hasOwnProperty.call(Node.prototype, 'isConnected')
        ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get
        : function () {
            const doc = ownerDocumentGetter.call(this);
            // IE11
            return (
            // if doc is null, it means `this` is actually a document instance which
            // is always connected
            doc === null ||
                (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0);
        };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { hasAttribute, getAttribute, setAttribute, removeAttribute, querySelectorAll: querySelectorAll$1, getBoundingClientRect, getElementsByTagName: getElementsByTagName$1, getElementsByTagNameNS: getElementsByTagNameNS$1, } = Element.prototype;
    const { addEventListener, removeEventListener } = Element.prototype;
    const innerHTMLSetter = hasOwnProperty.call(Element.prototype, 'innerHTML')
        ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML').set; // IE11
    const outerHTMLSetter = hasOwnProperty.call(Element.prototype, 'outerHTML')
        ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML').set
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML').set; // IE11
    const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
    const tabIndexGetter = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex').get;
    const matches = hasOwnProperty.call(Element.prototype, 'matches')
        ? Element.prototype.matches
        : Element.prototype.msMatchesSelector; // IE11
    const childrenGetter = hasOwnProperty.call(Element.prototype, 'children')
        ? getOwnPropertyDescriptor(Element.prototype, 'children').get
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get; // IE11
    // for IE11, access from HTMLElement
    // for all other browsers access the method from the parent Element interface
    const { getElementsByClassName: getElementsByClassName$1 } = HTMLElement.prototype;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ShadowRootHostGetter = typeof window.ShadowRoot !== 'undefined'
        ? getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'host').get
        : () => {
            throw new Error('Internal Error: Missing ShadowRoot');
        };
    const dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11
    const isNativeShadowRootAvailable = typeof window.ShadowRoot !== 'undefined';
    const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
    const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
    const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLWC(element) {
        return element instanceof Element && tagNameGetter.call(element).indexOf('-') !== -1;
    }
    function isShadowRoot(elmOrShadow) {
        return !(elmOrShadow instanceof Element) && 'host' in elmOrShadow;
    }
    function getFormattedComponentStack(elm) {
        const componentStack = [];
        const indentationChar = '\t';
        let indentation = '';
        let currentElement = elm;
        do {
            if (isLWC(currentElement)) {
                ArrayPush.call(componentStack, `${indentation}<${StringToLowerCase.call(tagNameGetter.call(currentElement))}>`);
                indentation = indentation + indentationChar;
            }
            if (isShadowRoot(currentElement)) {
                // if at some point we find a ShadowRoot, it must be a native shadow root.
                currentElement = ShadowRootHostGetter.call(currentElement);
            }
            else {
                currentElement = parentNodeGetter.call(currentElement);
            }
        } while (!isNull(currentElement));
        return ArrayJoin.call(componentStack, '\n');
    }
    const assert = {
        invariant(value, msg) {
            if (!value) {
                throw new Error(`Invariant Violation: ${msg}`);
            }
        },
        isTrue(value, msg) {
            if (!value) {
                throw new Error(`Assert Violation: ${msg}`);
            }
        },
        isFalse(value, msg) {
            if (value) {
                throw new Error(`Assert Violation: ${msg}`);
            }
        },
        fail(msg) {
            throw new Error(msg);
        },
        logError(message, elm) {
            let msg = `[LWC error]: ${message}`;
            if (elm) {
                msg = `${msg}\n${getFormattedComponentStack(elm)}`;
            }
            try {
                throw new Error(msg);
            }
            catch (e) {
                /* eslint-disable-next-line no-console */
                console.error(e);
            }
        },
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Helpful for tests running with jsdom
    function getOwnerDocument(node) {
        const doc = ownerDocumentGetter.call(node);
        // if doc is null, it means `this` is actually a document instance
        return doc === null ? node : doc;
    }
    function getOwnerWindow(node) {
        const doc = getOwnerDocument(node);
        const win = defaultViewGetter.call(doc);
        if (win === null) {
            // this method should never be called with a node that is not part
            // of a qualifying connected node.
            throw new TypeError();
        }
        return win;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    function pathComposer(startNode, composed) {
        const composedPath = [];
        let current = startNode;
        const startRoot = startNode instanceof Window ? startNode : patchedGetRootNode$1.call(startNode);
        while (current) {
            composedPath.push(current);
            if (current.assignedSlot) {
                current = current.assignedSlot;
            }
            else if (current.nodeType === DOCUMENT_FRAGMENT_NODE &&
                current.host &&
                (composed || current !== startRoot)) {
                current = current.host;
            }
            else {
                current = current.parentNode;
            }
        }
        let doc;
        if (startNode instanceof Window) {
            doc = startNode.document;
        }
        else {
            doc = getOwnerDocument(startNode);
        }
        // event composedPath includes window when startNode's ownerRoot is document
        if (composedPath[composedPath.length - 1] === doc) {
            composedPath.push(window);
        }
        return composedPath;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    function retarget(refNode, path) {
        if (isNull(refNode)) {
            return null;
        }
        // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
        // shadow-including inclusive ancestor, return ANCESTOR.
        const refNodePath = pathComposer(refNode, true);
        const p$ = path;
        for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
            ancestor = p$[i];
            root = ancestor instanceof Window ? ancestor : patchedGetRootNode$1.call(ancestor);
            if (root !== lastRoot) {
                rootIdx = refNodePath.indexOf(root);
                lastRoot = root;
            }
            if (!(root instanceof SyntheticShadowRoot) || rootIdx > -1) {
                return ancestor;
            }
        }
        return null;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { addEventListener: windowAddEventListener, removeEventListener: windowRemoveEventListener, } = window;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function doesEventNeedsPatch(e) {
        const originalTarget = eventTargetGetter.call(e);
        return originalTarget instanceof Node && isNodeShadowed(originalTarget);
    }
    function getEventListenerWrapper(fnOrObj) {
        let wrapperFn = null;
        try {
            wrapperFn = fnOrObj.$$lwcEventWrapper$$;
            if (!wrapperFn) {
                const isHandlerFunction = typeof fnOrObj === 'function';
                wrapperFn = fnOrObj.$$lwcEventWrapper$$ = function (e) {
                    // we don't want to patch every event, only when the original target is coming
                    // from inside a synthetic shadow
                    if (doesEventNeedsPatch(e)) {
                        patchEvent(e);
                    }
                    return isHandlerFunction
                        ? fnOrObj.call(this, e)
                        : fnOrObj.handleEvent && fnOrObj.handleEvent(e);
                };
            }
        }
        catch (e) {
            /** ignore */
        }
        return wrapperFn;
    }
    function windowAddEventListener$1(type, fnOrObj, optionsOrCapture) {
        const handlerType = typeof fnOrObj;
        // bail if `fnOrObj` is not a function, not an object
        if (handlerType !== 'function' && handlerType !== 'object') {
            return;
        }
        // bail if `fnOrObj` is an object without a `handleEvent` method
        if (handlerType === 'object' &&
            (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
            return;
        }
        const wrapperFn = getEventListenerWrapper(fnOrObj);
        windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
    }
    function windowRemoveEventListener$1(type, fnOrObj, optionsOrCapture) {
        const wrapperFn = getEventListenerWrapper(fnOrObj);
        windowRemoveEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
    }
    function addEventListener$1(type, fnOrObj, optionsOrCapture) {
        const handlerType = typeof fnOrObj;
        // bail if `fnOrObj` is not a function, not an object
        if (handlerType !== 'function' && handlerType !== 'object') {
            return;
        }
        // bail if `fnOrObj` is an object without a `handleEvent` method
        if (handlerType === 'object' &&
            (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
            return;
        }
        const wrapperFn = getEventListenerWrapper(fnOrObj);
        addEventListener.call(this, type, wrapperFn, optionsOrCapture);
    }
    function removeEventListener$1(type, fnOrObj, optionsOrCapture) {
        const wrapperFn = getEventListenerWrapper(fnOrObj);
        removeEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
    }
    // TODO: #1305 - these patches should be on EventTarget.prototype instead of win and node protos
    function windowPatchListeners() {
        window.addEventListener = windowAddEventListener$1;
        window.removeEventListener = windowRemoveEventListener$1;
    }
    function nodePatchListeners() {
        Node.prototype.addEventListener = addEventListener$1;
        Node.prototype.removeEventListener = removeEventListener$1;
    }
    function apply() {
        windowPatchListeners();
        nodePatchListeners();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // intentionally extracting the patched addEventListener and removeEventListener from Node.prototype
    // due to the issues with JSDOM patching hazard.
    const { addEventListener: addEventListener$2, removeEventListener: removeEventListener$2 } = Node.prototype;
    var EventListenerContext;
    (function (EventListenerContext) {
        EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
        EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
    })(EventListenerContext || (EventListenerContext = {}));
    const eventToContextMap = new WeakMap();
    function isChildNode(root, node) {
        return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
    }
    const GET_ROOT_NODE_CONFIG_FALSE = { composed: false };
    function getRootNodeHost(node, options) {
        let rootNode = patchedGetRootNode$1.call(node, options);
        // is SyntheticShadowRootInterface
        if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
            rootNode = getHost(rootNode);
        }
        return rootNode;
    }
    function targetGetter() {
        // currentTarget is always defined
        const originalCurrentTarget = eventCurrentTargetGetter.call(this);
        const originalTarget = eventTargetGetter.call(this);
        const composedPath = pathComposer(originalTarget, this.composed);
        const doc = getOwnerDocument(originalTarget);
        // Handle cases where the currentTarget is null (for async events),
        // and when an event has been added to Window
        if (!(originalCurrentTarget instanceof Node)) {
            // TODO: issue #1511 - Special escape hatch to support legacy behavior. Should be fixed.
            // If the event's target is being accessed async and originalTarget is not a keyed element, do not retarget
            if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
                return originalTarget;
            }
            return retarget(doc, composedPath);
        }
        else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
            // TODO: issue #1530 - If currentTarget is document or document.body (Third party libraries that have global event listeners)
            // and the originalTarget is not a keyed element, do not retarget
            if (isUndefined(getNodeOwnerKey(originalTarget))) {
                return originalTarget;
            }
            return retarget(doc, composedPath);
        }
        const eventContext = eventToContextMap.get(this);
        const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
            ? getShadowRoot(originalCurrentTarget)
            : originalCurrentTarget;
        return retarget(currentTarget, composedPath);
    }
    function composedPathValue() {
        const originalTarget = eventTargetGetter.call(this);
        return pathComposer(originalTarget, this.composed);
    }
    function patchEvent(event) {
        if (eventToContextMap.has(event)) {
            return; // already patched
        }
        defineProperties(event, {
            target: {
                get: targetGetter,
                enumerable: true,
                configurable: true,
            },
            composedPath: {
                value: composedPathValue,
                writable: true,
                enumerable: true,
                configurable: true,
            },
            // non-standard but important accessor
            srcElement: {
                get: targetGetter,
                enumerable: true,
                configurable: true,
            },
            path: {
                get: composedPathValue,
                enumerable: true,
                configurable: true,
            },
        });
        // not all events implement the relatedTarget getter, that's why we need to extract it from the instance
        // Note: we can't really use the super here because of issues with the typescript transpilation for accessors
        const originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');
        if (!isUndefined(originalRelatedTargetDescriptor)) {
            const relatedTargetGetter = originalRelatedTargetDescriptor.get;
            defineProperty(event, 'relatedTarget', {
                get() {
                    const eventContext = eventToContextMap.get(this);
                    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
                    const relatedTarget = relatedTargetGetter.call(this);
                    if (isNull(relatedTarget)) {
                        return null;
                    }
                    const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
                        ? getShadowRoot(originalCurrentTarget) /* because the context is a host */
                        : originalCurrentTarget;
                    return retarget(currentTarget, pathComposer(relatedTarget, true));
                },
                enumerable: true,
                configurable: true,
            });
        }
        eventToContextMap.set(event, 0);
    }
    const customElementToWrappedListeners = new WeakMap();
    function getEventMap(elm) {
        let listenerInfo = customElementToWrappedListeners.get(elm);
        if (isUndefined(listenerInfo)) {
            listenerInfo = create(null);
            customElementToWrappedListeners.set(elm, listenerInfo);
        }
        return listenerInfo;
    }
    const shadowRootEventListenerMap = new WeakMap();
    function getWrappedShadowRootListener(sr, listener) {
        if (!isFunction(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
        if (isUndefined(shadowRootWrappedListener)) {
            shadowRootWrappedListener = function (event) {
                // * if the event is dispatched directly on the host, it is not observable from root
                // * if the event is dispatched in an element that does not belongs to the shadow and it is not composed,
                //   it is not observable from the root
                const { composed } = event;
                const target = eventTargetGetter.call(event);
                const currentTarget = eventCurrentTargetGetter.call(event);
                if (target !== currentTarget) {
                    const rootNode = getRootNodeHost(target /* because wrapping on shadowRoot */, {
                        composed,
                    });
                    if (isChildNode(rootNode, currentTarget) ||
                        (composed === false && rootNode === currentTarget)) {
                        listener.call(sr, event);
                    }
                }
            };
            shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;
            {
                shadowRootWrappedListener.original = listener; // for logging purposes
            }
            shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
        }
        return shadowRootWrappedListener;
    }
    const customElementEventListenerMap = new WeakMap();
    function getWrappedCustomElementListener(elm, listener) {
        if (!isFunction(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        let customElementWrappedListener = customElementEventListenerMap.get(listener);
        if (isUndefined(customElementWrappedListener)) {
            customElementWrappedListener = function (event) {
                if (isValidEventForCustomElement(event)) {
                    // all handlers on the custom element should be called with undefined 'this'
                    listener.call(elm, event);
                }
            };
            customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;
            {
                customElementWrappedListener.original = listener; // for logging purposes
            }
            customElementEventListenerMap.set(listener, customElementWrappedListener);
        }
        return customElementWrappedListener;
    }
    function domListener(evt) {
        let immediatePropagationStopped = false;
        let propagationStopped = false;
        const { type, stopImmediatePropagation, stopPropagation } = evt;
        // currentTarget is always defined
        const currentTarget = eventCurrentTargetGetter.call(evt);
        const listenerMap = getEventMap(currentTarget);
        const listeners = listenerMap[type]; // it must have listeners at this point
        defineProperty(evt, 'stopImmediatePropagation', {
            value() {
                immediatePropagationStopped = true;
                stopImmediatePropagation.call(evt);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(evt, 'stopPropagation', {
            value() {
                propagationStopped = true;
                stopPropagation.call(evt);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        // in case a listener adds or removes other listeners during invocation
        const bookkeeping = ArraySlice.call(listeners);
        function invokeListenersByPlacement(placement) {
            forEach.call(bookkeeping, (listener) => {
                if (isFalse(immediatePropagationStopped) && listener.placement === placement) {
                    // making sure that the listener was not removed from the original listener queue
                    if (ArrayIndexOf.call(listeners, listener) !== -1) {
                        // all handlers on the custom element should be called with undefined 'this'
                        listener.call(undefined, evt);
                    }
                }
            });
        }
        eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
        invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);
        if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {
            // doing the second iteration only if the first one didn't interrupt the event propagation
            eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
            invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
        }
        eventToContextMap.set(evt, 0);
    }
    function attachDOMListener(elm, type, wrappedListener) {
        const listenerMap = getEventMap(elm);
        let cmpEventHandlers = listenerMap[type];
        if (isUndefined(cmpEventHandlers)) {
            cmpEventHandlers = listenerMap[type] = [];
        }
        // only add to DOM if there is no other listener on the same placement yet
        if (cmpEventHandlers.length === 0) {
            addEventListener$2.call(elm, type, domListener);
        }
        ArrayPush.call(cmpEventHandlers, wrappedListener);
    }
    function detachDOMListener(elm, type, wrappedListener) {
        const listenerMap = getEventMap(elm);
        let p;
        let listeners;
        if (!isUndefined((listeners = listenerMap[type])) &&
            (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
            ArraySplice.call(listeners, p, 1);
            // only remove from DOM if there is no other listener on the same placement
            if (listeners.length === 0) {
                removeEventListener$2.call(elm, type, domListener);
            }
        }
    }
    function isValidEventForCustomElement(event) {
        const target = eventTargetGetter.call(event);
        const currentTarget = eventCurrentTargetGetter.call(event);
        const { composed } = event;
        return (
        // it is composed, and we should always get it, or
        composed === true ||
            // it is dispatched onto the custom element directly, or
            target === currentTarget ||
            // it is coming from a slotted element
            isChildNode(getRootNodeHost(target /* because wrap on shadowRoot */, GET_ROOT_NODE_CONFIG_FALSE), currentTarget));
    }
    function addCustomElementEventListener(elm, type, listener, options) {
        {
            assert.invariant(isFunction(listener), `Invalid second argument for this.addEventListener() in ${toString(elm)} for event "${type}". Expected an EventListener but received ${listener}.`);
            // TODO: #420 - this is triggered when the component author attempts to add a listener
            // programmatically into a lighting element node
            if (!isUndefined(options)) {
                assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', elm);
            }
        }
        const wrappedListener = getWrappedCustomElementListener(elm, listener);
        attachDOMListener(elm, type, wrappedListener);
    }
    function removeCustomElementEventListener(elm, type, listener, _options) {
        const wrappedListener = getWrappedCustomElementListener(elm, listener);
        detachDOMListener(elm, type, wrappedListener);
    }
    function addShadowRootEventListener(sr, type, listener, options) {
        {
            assert.invariant(isFunction(listener), `Invalid second argument for this.template.addEventListener() in ${toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
            // TODO: #420 - this is triggered when the component author attempts to add a listener
            // programmatically into its Component's shadow root
            if (!isUndefined(options)) {
                assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', getHost(sr));
            }
        }
        const elm = getHost(sr);
        const wrappedListener = getWrappedShadowRootListener(sr, listener);
        attachDOMListener(elm, type, wrappedListener);
    }
    function removeShadowRootEventListener(sr, type, listener, _options) {
        const elm = getHost(sr);
        const wrappedListener = getWrappedShadowRootListener(sr, listener);
        detachDOMListener(elm, type, wrappedListener);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
    function createFieldName(key) {
        // @ts-ignore: using a string as a symbol for perf reasons
        return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${key}$$`;
    }
    function setInternalField(o, fieldName, value) {
        // TODO: #1299 - improve this to use a WeakMap
        defineProperty(o, fieldName, {
            value,
        });
    }
    function getInternalField(o, fieldName) {
        return o[fieldName];
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getTextContent(node) {
        switch (node.nodeType) {
            case Node.ELEMENT_NODE: {
                const childNodes = getFilteredChildNodes(node);
                let content = '';
                for (let i = 0, len = childNodes.length; i < len; i += 1) {
                    content += getTextContent(childNodes[i]);
                }
                return content;
            }
            default:
                return node.nodeValue;
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const Items = createFieldName('items');
    function StaticNodeList() {
        throw new TypeError('Illegal constructor');
    }
    StaticNodeList.prototype = create(NodeList.prototype, {
        constructor: {
            writable: true,
            configurable: true,
            value: StaticNodeList,
        },
        item: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(index) {
                return this[index];
            },
        },
        length: {
            enumerable: true,
            configurable: true,
            get() {
                return getInternalField(this, Items).length;
            },
        },
        // Iterator protocol
        forEach: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(cb, thisArg) {
                forEach.call(getInternalField(this, Items), cb, thisArg);
            },
        },
        entries: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                return ArrayMap.call(getInternalField(this, Items), (v, i) => [i, v]);
            },
        },
        keys: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                return ArrayMap.call(getInternalField(this, Items), (v, i) => i);
            },
        },
        values: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                return getInternalField(this, Items);
            },
        },
        [Symbol.iterator]: {
            writable: true,
            configurable: true,
            value() {
                let nextIndex = 0;
                return {
                    next: () => {
                        const items = getInternalField(this, Items);
                        return nextIndex < items.length
                            ? {
                                value: items[nextIndex++],
                                done: false,
                            }
                            : {
                                done: true,
                            };
                    },
                };
            },
        },
        [Symbol.toStringTag]: {
            configurable: true,
            get() {
                return 'NodeList';
            },
        },
        // IE11 doesn't support Symbol.toStringTag, in which case we
        // provide the regular toString method.
        toString: {
            writable: true,
            configurable: true,
            value() {
                return '[object NodeList]';
            },
        },
    });
    // prototype inheritance dance
    setPrototypeOf(StaticNodeList, NodeList);
    function createStaticNodeList(items) {
        const nodeList = create(StaticNodeList.prototype);
        setInternalField(nodeList, Items, items);
        // setting static indexes
        forEach.call(items, (item, index) => {
            defineProperty(nodeList, index, {
                value: item,
                enumerable: true,
                configurable: true,
            });
        });
        return nodeList;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const Items$1 = createFieldName('items');
    function isValidHTMLCollectionName(name) {
        return name !== 'length' && isNaN(name);
    }
    function getNodeHTMLCollectionName(node) {
        return node.getAttribute('id') || node.getAttribute('name');
    }
    function StaticHTMLCollection() {
        throw new TypeError('Illegal constructor');
    }
    StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
        constructor: {
            writable: true,
            configurable: true,
            value: StaticHTMLCollection,
        },
        item: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(index) {
                return this[index];
            },
        },
        length: {
            enumerable: true,
            configurable: true,
            get() {
                return getInternalField(this, Items$1).length;
            },
        },
        // https://dom.spec.whatwg.org/#dom-htmlcollection-nameditem-key
        namedItem: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(name) {
                if (isValidHTMLCollectionName(name) && this[name]) {
                    return this[name];
                }
                const items = getInternalField(this, Items$1);
                // Note: loop in reverse so that the first named item matches the named property
                for (let len = items.length - 1; len >= 0; len -= 1) {
                    const item = items[len];
                    const nodeName = getNodeHTMLCollectionName(item);
                    if (nodeName === name) {
                        return item;
                    }
                }
                return null;
            },
        },
        // Iterator protocol
        forEach: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(cb, thisArg) {
                forEach.call(getInternalField(this, Items$1), cb, thisArg);
            },
        },
        entries: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                return ArrayMap.call(getInternalField(this, Items$1), (v, i) => [i, v]);
            },
        },
        keys: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                return ArrayMap.call(getInternalField(this, Items$1), (v, i) => i);
            },
        },
        values: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                return getInternalField(this, Items$1);
            },
        },
        [Symbol.iterator]: {
            writable: true,
            configurable: true,
            value() {
                let nextIndex = 0;
                return {
                    next: () => {
                        const items = getInternalField(this, Items$1);
                        return nextIndex < items.length
                            ? {
                                value: items[nextIndex++],
                                done: false,
                            }
                            : {
                                done: true,
                            };
                    },
                };
            },
        },
        [Symbol.toStringTag]: {
            configurable: true,
            get() {
                return 'HTMLCollection';
            },
        },
        // IE11 doesn't support Symbol.toStringTag, in which case we
        // provide the regular toString method.
        toString: {
            writable: true,
            configurable: true,
            value() {
                return '[object HTMLCollection]';
            },
        },
    });
    // prototype inheritance dance
    setPrototypeOf(StaticHTMLCollection, HTMLCollection);
    function createStaticHTMLCollection(items) {
        const collection = create(StaticHTMLCollection.prototype);
        setInternalField(collection, Items$1, items);
        // setting static indexes
        forEach.call(items, (item, index) => {
            defineProperty(collection, index, {
                value: item,
                enumerable: true,
                configurable: true,
            });
        });
        return collection;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getInnerHTML(node) {
        let s = '';
        const childNodes = getFilteredChildNodes(node);
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
            s += getOuterHTML(childNodes[i]);
        }
        return s;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString
    const escapeAttrRegExp = /[&\u00A0"]/g;
    const escapeDataRegExp = /[&\u00A0<>]/g;
    const { replace, toLowerCase } = String.prototype;
    function escapeReplace(c) {
        switch (c) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '"':
                return '&quot;';
            case '\u00A0':
                return '&nbsp;';
            default:
                return '';
        }
    }
    function escapeAttr(s) {
        return replace.call(s, escapeAttrRegExp, escapeReplace);
    }
    function escapeData(s) {
        return replace.call(s, escapeDataRegExp, escapeReplace);
    }
    // http://www.whatwg.org/specs/web-apps/current-work/#void-elements
    const voidElements = new Set([
        'AREA',
        'BASE',
        'BR',
        'COL',
        'COMMAND',
        'EMBED',
        'HR',
        'IMG',
        'INPUT',
        'KEYGEN',
        'LINK',
        'META',
        'PARAM',
        'SOURCE',
        'TRACK',
        'WBR',
    ]);
    const plaintextParents = new Set([
        'STYLE',
        'SCRIPT',
        'XMP',
        'IFRAME',
        'NOEMBED',
        'NOFRAMES',
        'PLAINTEXT',
        'NOSCRIPT',
    ]);
    function getOuterHTML(node) {
        switch (node.nodeType) {
            case Node.ELEMENT_NODE: {
                const { attributes: attrs } = node;
                const tagName = tagNameGetter.call(node);
                let s = '<' + toLowerCase.call(tagName);
                for (let i = 0, attr; (attr = attrs[i]); i++) {
                    s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
                }
                s += '>';
                if (voidElements.has(tagName)) {
                    return s;
                }
                return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
            }
            case Node.TEXT_NODE: {
                const { data, parentNode } = node;
                if (parentNode instanceof Element &&
                    plaintextParents.has(tagNameGetter.call(parentNode))) {
                    return data;
                }
                return escapeData(data);
            }
            case Node.COMMENT_NODE: {
                return '<!--' + node.data + '-->';
            }
            default: {
                throw new Error();
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ShadowRootResolverKey = '$shadowResolver$';
    const InternalSlot = createFieldName('shadowRecord');
    const { createDocumentFragment } = document;
    function getInternalSlot(root) {
        const record = getInternalField(root, InternalSlot);
        if (isUndefined(record)) {
            throw new TypeError();
        }
        return record;
    }
    const ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
    defineProperty(Node.prototype, ShadowRootResolverKey, {
        set(fn) {
            this[ShadowResolverPrivateKey] = fn;
            // TODO: #1164 - temporary propagation of the key
            setNodeOwnerKey(this, fn.nodeKey);
        },
        get() {
            return this[ShadowResolverPrivateKey];
        },
        configurable: true,
        enumerable: true,
    });
    function getShadowRootResolver(node) {
        return node[ShadowRootResolverKey];
    }
    function setShadowRootResolver(node, fn) {
        node[ShadowRootResolverKey] = fn;
    }
    function isDelegatingFocus(host) {
        return getInternalSlot(host).delegatesFocus;
    }
    function getHost(root) {
        return getInternalSlot(root).host;
    }
    function getShadowRoot(elm) {
        return getInternalSlot(elm).shadowRoot;
    }
    function hasSyntheticShadow(elm) {
        return !isUndefined(getInternalField(elm, InternalSlot));
    }
    let uid = 0;
    function attachShadow(elm, options) {
        if (!isUndefined(getInternalField(elm, InternalSlot))) {
            throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
        }
        const { mode, delegatesFocus } = options;
        // creating a real fragment for shadowRoot instance
        const doc = getOwnerDocument(elm);
        const sr = createDocumentFragment.call(doc);
        // creating shadow internal record
        const record = {
            mode,
            delegatesFocus: !!delegatesFocus,
            host: elm,
            shadowRoot: sr,
        };
        setInternalField(sr, InternalSlot, record);
        setInternalField(elm, InternalSlot, record);
        const shadowResolver = () => sr;
        const x = (shadowResolver.nodeKey = uid++);
        setNodeKey(elm, x);
        setShadowRootResolver(sr, shadowResolver);
        // correcting the proto chain
        setPrototypeOf(sr, SyntheticShadowRoot.prototype);
        return sr;
    }
    const SyntheticShadowRootDescriptors = {
        constructor: {
            writable: true,
            configurable: true,
            value: SyntheticShadowRoot,
        },
        toString: {
            writable: true,
            configurable: true,
            value() {
                return `[object ShadowRoot]`;
            },
        },
    };
    const ShadowRootDescriptors = {
        activeElement: {
            enumerable: true,
            configurable: true,
            get() {
                const host = getHost(this);
                const doc = getOwnerDocument(host);
                const activeElement = DocumentPrototypeActiveElement.call(doc);
                if (isNull(activeElement)) {
                    return activeElement;
                }
                if ((compareDocumentPosition.call(host, activeElement) &
                    DOCUMENT_POSITION_CONTAINED_BY) ===
                    0) {
                    return null;
                }
                // activeElement must be child of the host and owned by it
                let node = activeElement;
                while (!isNodeOwnedBy(host, node)) {
                    // parentElement is always an element because we are talking up the tree knowing
                    // that it is a child of the host.
                    node = parentElementGetter.call(node);
                }
                // If we have a slot element here that means that we were dealing
                // with an element that was passed to one of our slots. In this
                // case, activeElement returns null.
                if (isSlotElement(node)) {
                    return null;
                }
                return node;
            },
        },
        delegatesFocus: {
            configurable: true,
            get() {
                return getInternalSlot(this).delegatesFocus;
            },
        },
        elementFromPoint: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(left, top) {
                const host = getHost(this);
                const doc = getOwnerDocument(host);
                const element = elementFromPoint.call(doc, left, top);
                if (isNull(element)) {
                    return element;
                }
                return retarget(this, pathComposer(element, true));
            },
        },
        elementsFromPoint: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(_left, _top) {
                throw new Error();
            },
        },
        getSelection: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                throw new Error();
            },
        },
        host: {
            enumerable: true,
            configurable: true,
            get() {
                return getHost(this);
            },
        },
        mode: {
            configurable: true,
            get() {
                return getInternalSlot(this).mode;
            },
        },
        styleSheets: {
            enumerable: true,
            configurable: true,
            get() {
                throw new Error();
            },
        },
    };
    const NodePatchDescriptors = {
        insertBefore: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(newChild, refChild) {
                insertBefore.call(getHost(this), newChild, refChild);
                return newChild;
            },
        },
        removeChild: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(oldChild) {
                removeChild.call(getHost(this), oldChild);
                return oldChild;
            },
        },
        appendChild: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(newChild) {
                appendChild.call(getHost(this), newChild);
                return newChild;
            },
        },
        replaceChild: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(newChild, oldChild) {
                replaceChild.call(getHost(this), newChild, oldChild);
                return oldChild;
            },
        },
        addEventListener: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(type, listener, options) {
                addShadowRootEventListener(this, type, listener, options);
            },
        },
        removeEventListener: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(type, listener, options) {
                removeShadowRootEventListener(this, type, listener, options);
            },
        },
        baseURI: {
            enumerable: true,
            configurable: true,
            get() {
                return getHost(this).baseURI;
            },
        },
        childNodes: {
            enumerable: true,
            configurable: true,
            get() {
                return createStaticNodeList(shadowRootChildNodes(this));
            },
        },
        compareDocumentPosition: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(otherNode) {
                const host = getHost(this);
                if (this === otherNode) {
                    // "this" and "otherNode" are the same shadow root.
                    return 0;
                }
                else if (this.contains(otherNode)) {
                    // "otherNode" belongs to the shadow tree where "this" is the shadow root.
                    return 20; // Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING
                }
                else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
                    // "otherNode" is in a different shadow tree contained by the shadow tree where "this" is the shadow root.
                    return 37; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
                }
                else {
                    // "otherNode" is in a different shadow tree that is not contained by the shadow tree where "this" is the shadow root.
                    return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
                }
            },
        },
        contains: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(otherNode) {
                if (this === otherNode) {
                    return true;
                }
                const host = getHost(this);
                // must be child of the host and owned by it.
                return ((compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                    0 && isNodeOwnedBy(host, otherNode));
            },
        },
        firstChild: {
            enumerable: true,
            configurable: true,
            get() {
                const childNodes = getInternalChildNodes(this);
                return childNodes[0] || null;
            },
        },
        lastChild: {
            enumerable: true,
            configurable: true,
            get() {
                const childNodes = getInternalChildNodes(this);
                return childNodes[childNodes.length - 1] || null;
            },
        },
        hasChildNodes: {
            writable: true,
            enumerable: true,
            configurable: true,
            value() {
                const childNodes = getInternalChildNodes(this);
                return childNodes.length > 0;
            },
        },
        isConnected: {
            enumerable: true,
            configurable: true,
            get() {
                return isConnected.call(getHost(this));
            },
        },
        nextSibling: {
            enumerable: true,
            configurable: true,
            get() {
                return null;
            },
        },
        previousSibling: {
            enumerable: true,
            configurable: true,
            get() {
                return null;
            },
        },
        nodeName: {
            enumerable: true,
            configurable: true,
            get() {
                return '#document-fragment';
            },
        },
        nodeType: {
            enumerable: true,
            configurable: true,
            get() {
                return 11; // Node.DOCUMENT_FRAGMENT_NODE
            },
        },
        nodeValue: {
            enumerable: true,
            configurable: true,
            get() {
                return null;
            },
        },
        ownerDocument: {
            enumerable: true,
            configurable: true,
            get() {
                return getHost(this).ownerDocument;
            },
        },
        parentElement: {
            enumerable: true,
            configurable: true,
            get() {
                return null;
            },
        },
        parentNode: {
            enumerable: true,
            configurable: true,
            get() {
                return null;
            },
        },
        textContent: {
            enumerable: true,
            configurable: true,
            get() {
                const childNodes = getInternalChildNodes(this);
                let textContent = '';
                for (let i = 0, len = childNodes.length; i < len; i += 1) {
                    textContent += getTextContent(childNodes[i]);
                }
                return textContent;
            },
            set(v) {
                const host = getHost(this);
                textContextSetter.call(host, v);
            },
        },
        // Since the synthetic shadow root is a detached DocumentFragment, short-circuit the getRootNode behavior
        getRootNode: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(options) {
                return !isUndefined(options) && isTrue(options.composed)
                    ? getHost(this).getRootNode(options)
                    : this;
            },
        },
    };
    const ElementPatchDescriptors = {
        innerHTML: {
            enumerable: true,
            configurable: true,
            get() {
                const childNodes = getInternalChildNodes(this);
                let innerHTML = '';
                for (let i = 0, len = childNodes.length; i < len; i += 1) {
                    innerHTML += getOuterHTML(childNodes[i]);
                }
                return innerHTML;
            },
            set(v) {
                const host = getHost(this);
                innerHTMLSetter.call(host, v);
            },
        },
    };
    const ParentNodePatchDescriptors = {
        childElementCount: {
            enumerable: true,
            configurable: true,
            get() {
                return this.children.length;
            },
        },
        children: {
            enumerable: true,
            configurable: true,
            get() {
                return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), (elm) => elm instanceof Element));
            },
        },
        firstElementChild: {
            enumerable: true,
            configurable: true,
            get() {
                return this.children[0] || null;
            },
        },
        lastElementChild: {
            enumerable: true,
            configurable: true,
            get() {
                const { children } = this;
                return children.item(children.length - 1) || null;
            },
        },
        querySelector: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(selectors) {
                return shadowRootQuerySelector(this, selectors);
            },
        },
        querySelectorAll: {
            writable: true,
            enumerable: true,
            configurable: true,
            value(selectors) {
                return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
            },
        },
    };
    assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
    function SyntheticShadowRoot() {
        throw new TypeError('Illegal constructor');
    }
    SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
    // Is native ShadowDom is available on window,
    // we need to make sure that our synthetic shadow dom
    // passed instanceof checks against window.ShadowDom
    if (isNativeShadowRootAvailable) {
        setPrototypeOf(SyntheticShadowRoot.prototype, window.ShadowRoot.prototype);
    }
    /**
     * This method is only intended to be used in non-production mode in IE11
     * and its role is to produce a 1-1 mapping between a shadowRoot instance
     * and a comment node that is intended to use to trick the IE11 DevTools
     * to show the content of the shadowRoot in the DOM Explorer.
     */
    function getIE11FakeShadowRootPlaceholder(host) {
        const shadowRoot = getShadowRoot(host);
        // @ts-ignore this $$placeholder$$ is not a security issue because you must
        // have access to the shadowRoot in order to extract the fake node, which give
        // you access to the same childNodes of the shadowRoot, so, who cares.
        let c = shadowRoot.$$placeholder$$;
        if (!isUndefined(c)) {
            return c;
        }
        const doc = getOwnerDocument(host);
        // @ts-ignore $$placeholder$$ is fine, read the node above.
        c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
        defineProperties(c, {
            childNodes: {
                get() {
                    return shadowRoot.childNodes;
                },
                enumerable: true,
                configurable: true,
            },
            tagName: {
                get() {
                    return `#shadow-root (${shadowRoot.mode})`;
                },
                enumerable: true,
                configurable: true,
            },
        });
        return c;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let MO = window.MutationObserver;
    // MutationObserver is not yet implemented in jsdom:
    // https://github.com/jsdom/jsdom/issues/639
    if (typeof MO === 'undefined') {
        /* eslint-disable-next-line no-inner-declarations */
        function MutationObserverMock() { }
        MutationObserverMock.prototype = {
            observe() {
                {
                    {
                        throw new Error(`MutationObserver should not be mocked outside of the jest test environment`);
                    }
                }
            },
        };
        MO = window.MutationObserver = MutationObserverMock;
    }
    const MutationObserver = MO;
    // Eventually, import the patched MutationObserver polyfill here
    // to ensure rest of the framework uses the patched version
    const MutationObserverObserve = MutationObserver.prototype.observe;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * Writing our own utils to handle NodeList and HTMLCollection. This is to not conflict with
     * some legacy third party libraries like prototype.js that patch Array.prototype.
     */
    /**
     * Custom implementation of filter since using Array.prototype.filter conflicts with other
     * legacy libraries like prototype.js
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Polyfill
     */
    function collectionFilter(collection, fn) {
        const res = [];
        const length = collection.length;
        for (let i = 0; i < length; i++) {
            const curr = collection[i];
            if (isTrue(fn(curr, i, collection))) {
                ArrayPush.call(res, curr);
            }
        }
        return res;
    }
    /**
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill
     */
    function collectionFind(collection, fn) {
        const length = collection.length;
        for (let i = 0; i < length; i++) {
            const curr = collection[i];
            if (isTrue(fn(curr, i, collection))) {
                return curr;
            }
        }
        return undefined;
    }
    /**
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Streamlining_cross-browser_behavior
     */
    function collectionSlice(collection, begin, end) {
        end = !isUndefined(end) ? end : collection.length;
        const cloned = [];
        const len = collection.length;
        // Handle negative value for "begin"
        let start = !isUndefined(begin) ? begin : 0;
        start = start >= 0 ? start : Math.max(0, len + start);
        // Handle negative value for "end"
        let upTo = !isUndefined(end) ? Math.min(end, len) : len;
        if (end < 0) {
            upTo = len + end;
        }
        // Actual expected size of the slice
        const size = upTo - start;
        if (size > 0) {
            for (let i = 0; i < size; i++) {
                ArrayPush.call(cloned, collection[start + i]);
            }
        }
        return cloned;
    }
    /**
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
     */
    function collectionIndexOf(collection, searchItem, fromIndex = 0) {
        const len = collection.length;
        let i = Math.min(fromIndex, len);
        if (i < 0) {
            i = Math.max(0, len + i);
        }
        else if (i >= len) {
            return -1;
        }
        for (; i !== len; ++i) {
            if (collection[i] === searchItem) {
                return i;
            }
        }
        return -1;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const TabbableElementsQuery = `
    button:not([tabindex="-1"]):not([disabled]),
    [contenteditable]:not([tabindex="-1"]),
    video[controls]:not([tabindex="-1"]),
    audio[controls]:not([tabindex="-1"]),
    [href]:not([tabindex="-1"]),
    input:not([tabindex="-1"]):not([disabled]),
    select:not([tabindex="-1"]):not([disabled]),
    textarea:not([tabindex="-1"]):not([disabled]),
    [tabindex="0"]
`;
    const DidAddMouseDownListener = createFieldName('DidAddMouseDownListener');
    function isVisible(element) {
        const { width, height } = getBoundingClientRect.call(element);
        const noZeroSize = width > 0 || height > 0;
        return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
    }
    // This function based on https://allyjs.io/data-tables/focusable.html
    // It won't catch everything, but should be good enough
    // There are a lot of edge cases here that we can't realistically handle
    // Determines if a particular element is tabbable, as opposed to simply focusable
    // Exported for jest purposes
    function isTabbable(element) {
        return matches.call(element, TabbableElementsQuery) && isVisible(element);
    }
    function getTabbableSegments(host) {
        const doc = getOwnerDocument(host);
        const all = querySelectorAll.call(doc, TabbableElementsQuery);
        const inner = collectionSlice(querySelectorAll$1.call(host, TabbableElementsQuery));
        {
            assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
        }
        const firstChild = inner[0];
        const lastChild = inner[inner.length - 1];
        const hostIndex = collectionIndexOf(all, host);
        // Host element can show up in our "previous" section if its tabindex is 0
        // We want to filter that out here
        const firstChildIndex = hostIndex > -1 ? hostIndex : collectionIndexOf(all, firstChild);
        // Account for an empty inner list
        const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : collectionIndexOf(all, lastChild) + 1;
        const prev = collectionSlice(all, 0, firstChildIndex);
        const next = collectionSlice(all, lastChildIndex);
        return {
            prev,
            inner,
            next,
        };
    }
    function getActiveElement(host) {
        const doc = getOwnerDocument(host);
        const activeElement = DocumentPrototypeActiveElement.call(doc);
        if (isNull(activeElement)) {
            return activeElement;
        }
        // activeElement must be child of the host and owned by it
        return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !==
            0
            ? activeElement
            : null;
    }
    function relatedTargetPosition(host, relatedTarget) {
        // assert: target must be child of host
        const pos = compareDocumentPosition.call(host, relatedTarget);
        if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
            // focus remains inside the host
            return 0;
        }
        else if (pos & DOCUMENT_POSITION_PRECEDING) {
            // focus is coming from above
            return 1;
        }
        else if (pos & DOCUMENT_POSITION_FOLLOWING) {
            // focus is coming from below
            return 2;
        }
        // we don't know what's going on.
        return -1;
    }
    function muteEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function muteFocusEventsDuringExecution(win, func) {
        windowAddEventListener.call(win, 'focusin', muteEvent, true);
        windowAddEventListener.call(win, 'focusout', muteEvent, true);
        func();
        windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
        windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
    }
    function focusOnNextOrBlur(segment, target, relatedTarget) {
        const win = getOwnerWindow(relatedTarget);
        const next = getNextTabbable(segment, relatedTarget);
        if (isNull(next)) {
            // nothing to focus on, blur to invalidate the operation
            muteFocusEventsDuringExecution(win, () => {
                target.blur();
            });
        }
        else {
            muteFocusEventsDuringExecution(win, () => {
                next.focus();
            });
        }
    }
    let letBrowserHandleFocus = false;
    function disableKeyboardFocusNavigationRoutines() {
        letBrowserHandleFocus = true;
    }
    function enableKeyboardFocusNavigationRoutines() {
        letBrowserHandleFocus = false;
    }
    function skipHostHandler(event) {
        if (letBrowserHandleFocus) {
            enableKeyboardFocusNavigationRoutines();
            return;
        }
        const host = eventCurrentTargetGetter.call(event);
        const target = eventTargetGetter.call(event);
        // If the host delegating focus with tabindex=0 is not the target, we know
        // that the event was dispatched on a descendant node of the host. This
        // means the focus is coming from below and we don't need to do anything.
        if (host !== target) {
            // Focus is coming from above
            return;
        }
        const relatedTarget = focusEventRelatedTargetGetter.call(event);
        if (isNull(relatedTarget)) {
            // If relatedTarget is null, the user is most likely tabbing into the document from the
            // browser chrome. We could probably deduce whether focus is coming in from the top or the
            // bottom by comparing the position of the target to all tabbable elements. This is an edge
            // case and only comes up if the custom element is the first or last tabbable element in the
            // document.
            return;
        }
        const segments = getTabbableSegments(host);
        const position = relatedTargetPosition(host, relatedTarget);
        if (position === 1) {
            // Focus is coming from above
            const findTabbableElms = isTabbableFrom.bind(null, patchedGetRootNode$1.call(host));
            const first = ArrayFind.call(segments.inner, findTabbableElms);
            if (!isUndefined(first)) {
                const win = getOwnerWindow(first);
                muteFocusEventsDuringExecution(win, () => {
                    first.focus();
                });
            }
            else {
                focusOnNextOrBlur(segments.next, target, relatedTarget);
            }
        }
        else if (host === target) {
            // Host is receiving focus from below, either from its shadow or from a sibling
            focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
        }
    }
    function skipShadowHandler(event) {
        if (letBrowserHandleFocus) {
            enableKeyboardFocusNavigationRoutines();
            return;
        }
        const relatedTarget = focusEventRelatedTargetGetter.call(event);
        if (isNull(relatedTarget)) {
            // If relatedTarget is null, the user is most likely tabbing into the document from the
            // browser chrome. We could probably deduce whether focus is coming in from the top or the
            // bottom by comparing the position of the target to all tabbable elements. This is an edge
            // case and only comes up if the custom element is the first or last tabbable element in the
            // document.
            return;
        }
        const host = eventCurrentTargetGetter.call(event);
        const segments = getTabbableSegments(host);
        if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
            // If relatedTarget is contained by the host's subtree we can assume that the user is
            // tabbing between elements inside of the shadow. Do nothing.
            return;
        }
        const target = eventTargetGetter.call(event);
        // Determine where the focus is coming from (Tab or Shift+Tab)
        const position = relatedTargetPosition(host, relatedTarget);
        if (position === 1) {
            // Focus is coming from above
            focusOnNextOrBlur(segments.next, target, relatedTarget);
        }
        if (position === 2) {
            // Focus is coming from below
            focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
        }
    }
    // Use this function to determine whether you can start from one root and end up
    // at another element via tabbing.
    function isTabbableFrom(fromRoot, toElm) {
        if (!isTabbable(toElm)) {
            return false;
        }
        const ownerDocument = getOwnerDocument(toElm);
        let root = patchedGetRootNode$1.call(toElm);
        while (root !== ownerDocument && root !== fromRoot) {
            const sr = root;
            const host = sr.host;
            if (getAttribute.call(host, 'tabindex') === '-1') {
                return false;
            }
            root = host && patchedGetRootNode$1.call(host);
        }
        return true;
    }
    function getNextTabbable(tabbables, relatedTarget) {
        const len = tabbables.length;
        if (len > 0) {
            for (let i = 0; i < len; i += 1) {
                const next = tabbables[i];
                if (isTabbableFrom(patchedGetRootNode$1.call(relatedTarget), next)) {
                    return next;
                }
            }
        }
        return null;
    }
    // Skips the host element
    function handleFocus(elm) {
        {
            assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
        }
        bindDocumentMousedownMouseupHandlers(elm);
        // Unbind any focusin listeners we may have going on
        ignoreFocusIn(elm);
        addEventListener.call(elm, 'focusin', skipHostHandler, true);
    }
    function ignoreFocus(elm) {
        removeEventListener.call(elm, 'focusin', skipHostHandler, true);
    }
    function bindDocumentMousedownMouseupHandlers(elm) {
        const ownerDocument = getOwnerDocument(elm);
        if (!getInternalField(ownerDocument, DidAddMouseDownListener)) {
            setInternalField(ownerDocument, DidAddMouseDownListener, true);
            addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
            // Although our sequential focus navigation routines also unset this
            // flag, we need a backup plan in case they don't execute (e.g., the
            // click doesn't result in focus entering the shadow).
            addEventListener.call(ownerDocument, 'mouseup', () => {
                // We schedule this as an async task in the mouseup handler (as
                // opposed to the mousedown handler) because we want to guarantee
                // that it will never run before the focusin handler:
                //
                // Click form element   | Click form element label
                // ==================================================
                // mousedown            | mousedown
                // FOCUSIN              | mousedown-setTimeout
                // mousedown-setTimeout | mouseup
                // mouseup              | FOCUSIN
                // mouseup-setTimeout   | mouseup-setTimeout
                setTimeout(enableKeyboardFocusNavigationRoutines);
            }, true);
        }
    }
    // Skips the shadow tree
    function handleFocusIn(elm) {
        {
            assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
        }
        bindDocumentMousedownMouseupHandlers(elm);
        // Unbind any focus listeners we may have going on
        ignoreFocus(elm);
        // This focusin listener is to catch focusin events from keyboard interactions
        // A better solution would perhaps be to listen for keydown events, but
        // the keydown event happens on whatever element already has focus (or no element
        // at all in the case of the location bar. So, instead we have to assume that focusin
        // without a mousedown means keyboard navigation
        addEventListener.call(elm, 'focusin', skipShadowHandler, true);
    }
    function ignoreFocusIn(elm) {
        removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const nativeGetRootNode = Node.prototype.getRootNode;
    /**
     * Get the root by climbing up the dom tree, beyond the shadow root
     * If Node.prototype.getRootNode is supported, use it
     * else, assume we are working in non-native shadow mode and climb using parentNode
     */
    const getDocumentOrRootNode = !isUndefined(nativeGetRootNode)
        ? nativeGetRootNode
        : function () {
            let node = this;
            let nodeParent;
            while (!isNull((nodeParent = parentNodeGetter.call(node)))) {
                node = nodeParent;
            }
            return node;
        };
    /**
     * Get the shadow root
     * getNodeOwner() returns the host element that owns the given node
     * Note: getNodeOwner() returns null when running in native-shadow mode.
     *  Fallback to using the native getRootNode() to discover the root node.
     *  This is because, it is not possible to inspect the node and decide if it is part
     *  of a native shadow or the synthetic shadow.
     * @param {Node} node
     */
    function getNearestRoot(node) {
        const ownerNode = getNodeOwner(node);
        if (isNull(ownerNode)) {
            // we hit a wall, either we are in native shadow mode or the node is not in lwc boundary.
            return getDocumentOrRootNode.call(node);
        }
        return getShadowRoot(ownerNode);
    }
    function patchedGetRootNode(options) {
        const composed = isUndefined(options) ? false : !!options.composed;
        return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
    }
    function apply$1() {
        defineProperty(Node.prototype, 'getRootNode', {
            value: patchedGetRootNode,
            enumerable: true,
            configurable: true,
            writable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$1();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // when finding a slot in the DOM, we can fold it if it is contained
    // inside another slot.
    function foldSlotElement(slot) {
        let parent = parentElementGetter.call(slot);
        while (!isNull(parent) && isSlotElement(parent)) {
            slot = parent;
            parent = parentElementGetter.call(slot);
        }
        return slot;
    }
    function isNodeSlotted(host, node) {
        {
            assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
            assert.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
            assert.isTrue(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
        }
        const hostKey = getNodeKey(host);
        // this routine assumes that the node is coming from a different shadow (it is not owned by the host)
        // just in case the provided node is not an element
        let currentElement = node instanceof Element ? node : parentElementGetter.call(node);
        while (!isNull(currentElement) && currentElement !== host) {
            const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
            const parent = parentElementGetter.call(currentElement);
            if (elmOwnerKey === hostKey) {
                // we have reached an element inside the host's template, and only if
                // that element is an slot, then the node is considered slotted
                return isSlotElement(currentElement);
            }
            else if (parent === host) {
                return false;
            }
            else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
                // we are crossing a boundary of some sort since the elm and its parent
                // have different owner key. for slotted elements, this is possible
                // if the parent happens to be a slot.
                if (isSlotElement(parent)) {
                    /**
                     * the slot parent might be allocated inside another slot, think of:
                     * <x-root> (<--- root element)
                     *    <x-parent> (<--- own by x-root)
                     *       <x-child> (<--- own by x-root)
                     *           <slot> (<--- own by x-child)
                     *               <slot> (<--- own by x-parent)
                     *                  <div> (<--- own by x-root)
                     *
                     * while checking if x-parent has the div slotted, we need to traverse
                     * up, but when finding the first slot, we skip that one in favor of the
                     * most outer slot parent before jumping into its corresponding host.
                     */
                    currentElement = getNodeOwner(foldSlotElement(parent));
                    if (!isNull(currentElement)) {
                        if (currentElement === host) {
                            // the slot element is a top level element inside the shadow
                            // of a host that was allocated into host in question
                            return true;
                        }
                        else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
                            // the slot element is an element inside the shadow
                            // of a host that was allocated into host in question
                            return true;
                        }
                    }
                }
                else {
                    return false;
                }
            }
            else {
                currentElement = parent;
            }
        }
        return false;
    }
    function getAllSlottedMatches(host, nodeList) {
        const filteredAndPatched = [];
        for (let i = 0, len = nodeList.length; i < len; i += 1) {
            const node = nodeList[i];
            if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
                ArrayPush.call(filteredAndPatched, node);
            }
        }
        return filteredAndPatched;
    }
    function getFirstSlottedMatch(host, nodeList) {
        for (let i = 0, len = nodeList.length; i < len; i += 1) {
            const node = nodeList[i];
            if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
                return node;
            }
        }
        return null;
    }
    function lightDomQuerySelectorAll(elm, selectors) {
        const owner = getNodeOwner(elm);
        if (isNull(owner)) {
            return [];
        }
        const nodeList = querySelectorAll$1.call(elm, selectors);
        if (getNodeKey(elm)) {
            // it is a custom element, and we should then filter by slotted elements
            return getAllSlottedMatches(elm, nodeList);
        }
        else {
            // regular element, we should then filter by ownership
            return getAllMatches(owner, nodeList);
        }
    }
    function lightDomQuerySelector(elm, selector) {
        const owner = getNodeOwner(elm);
        if (isNull(owner)) {
            // the it is a root, and those can't have a lightdom
            return null;
        }
        const nodeList = querySelectorAll$1.call(elm, selector);
        if (getNodeKey(elm)) {
            // it is a custom element, and we should then filter by slotted elements
            return getFirstSlottedMatch(elm, nodeList);
        }
        else {
            // regular element, we should then filter by ownership
            return getFirstMatch(owner, nodeList);
        }
    }
    function PatchedElement(elm) {
        const Ctor = PatchedNode(elm);
        const { addEventListener: superAddEventListener, removeEventListener: superRemoveEventListener, blur: superBlur, focus: superFocus, } = elm;
        // Note: Element.getElementsByTagName and Element.getElementsByClassName are purposefully
        // omitted from the list of patched methods. In order for the querySelector* APIs to run
        // properly in jsdom, we need to make sure those methods doesn't respect the shadow DOM
        // semantic.
        // https://github.com/salesforce/lwc/pull/1179#issuecomment-484041707
        return class PatchedHTMLElement extends Ctor {
            // Regular Elements
            querySelector(selector) {
                return lightDomQuerySelector(this, selector);
            }
            querySelectorAll(selectors) {
                return createStaticNodeList(lightDomQuerySelectorAll(this, selectors));
            }
            get innerHTML() {
                const childNodes = getInternalChildNodes(this);
                let innerHTML = '';
                for (let i = 0, len = childNodes.length; i < len; i += 1) {
                    innerHTML += getOuterHTML(childNodes[i]);
                }
                return innerHTML;
            }
            set innerHTML(value) {
                innerHTMLSetter.call(this, value);
            }
            get outerHTML() {
                return getOuterHTML(this);
            }
            set outerHTML(value) {
                outerHTMLSetter.call(this, value);
            }
            // CE patches
            attachShadow(options) {
                return attachShadow(this, options);
            }
            addEventListener(type, listener, options) {
                if (hasSyntheticShadow(this)) {
                    addCustomElementEventListener(this, type, listener, options);
                }
                else {
                    superAddEventListener.call(this, type, listener, options);
                }
            }
            removeEventListener(type, listener, options) {
                if (hasSyntheticShadow(this)) {
                    removeCustomElementEventListener(this, type, listener, options);
                }
                else {
                    superRemoveEventListener.call(this, type, listener, options);
                }
            }
            get shadowRoot() {
                if (hasSyntheticShadow(this)) {
                    const shadow = getShadowRoot(this);
                    if (shadow.mode === 'open') {
                        return shadow;
                    }
                }
                return null;
            }
            get tabIndex() {
                if (hasSyntheticShadow(this) &&
                    isDelegatingFocus(this) &&
                    isFalse(hasAttribute.call(this, 'tabindex'))) {
                    // this cover the case where the default tabindex should be 0 because the
                    // custom element is delegating its focus
                    return 0;
                }
                // NOTE: Technically this should be `super.tabIndex` however Typescript
                // has a known bug while transpiling down to ES5
                // https://github.com/Microsoft/TypeScript/issues/338
                const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                return descriptor.get.call(this);
            }
            set tabIndex(value) {
                if (hasSyntheticShadow(this)) {
                    // This tabIndex setter might be confusing unless it is understood that HTML
                    // elements have default tabIndex property values. Natively focusable elements have
                    // a default tabIndex value of 0 and all other elements have a default tabIndex
                    // value of -1. For example, the tabIndex property value is -1 for both <x-foo> and
                    // <x-foo tabindex="-1">, but our delegatesFocus polyfill should only kick in for
                    // the latter case when the value of the tabindex attribute is -1.
                    const delegatesFocus = isDelegatingFocus(this);
                    // Record the state of things before invoking component setter.
                    const prevValue = tabIndexGetter.call(this);
                    const prevHasAttr = hasAttribute.call(this, 'tabindex');
                    // NOTE: Technically this should be `super.tabIndex` however Typescript
                    // has a known bug while transpiling down to ES5
                    // https://github.com/Microsoft/TypeScript/issues/338
                    const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                    descriptor.set.call(this, value);
                    // Record the state of things after invoking component setter.
                    const currValue = tabIndexGetter.call(this);
                    const currHasAttr = hasAttribute.call(this, 'tabindex');
                    const didValueChange = prevValue !== currValue;
                    // If the tabindex attribute is initially rendered, we can assume that this setter has
                    // previously executed and a listener has been added. We must remove that listener if
                    // the tabIndex property value has changed or if the component no longer renders a
                    // tabindex attribute.
                    if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {
                        if (prevValue === -1) {
                            ignoreFocusIn(this);
                        }
                        if (prevValue === 0 && delegatesFocus) {
                            ignoreFocus(this);
                        }
                    }
                    // If a tabindex attribute was not rendered after invoking its setter, it means the
                    // component is taking control. Do nothing.
                    if (isFalse(currHasAttr)) {
                        return;
                    }
                    // If the tabindex attribute is initially rendered, we can assume that this setter has
                    // previously executed and a listener has been added. If the tabindex attribute is still
                    // rendered after invoking the setter AND the tabIndex property value has not changed,
                    // we don't need to do any work.
                    if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {
                        return;
                    }
                    // At this point we know that a tabindex attribute was rendered after invoking the
                    // setter and that either:
                    // 1) This is the first time this setter is being invoked.
                    // 2) This is not the first time this setter is being invoked and the value is changing.
                    // We need to add the appropriate listeners in either case.
                    if (currValue === -1) {
                        // Add the magic to skip the shadow tree
                        handleFocusIn(this);
                    }
                    if (currValue === 0 && delegatesFocus) {
                        // Add the magic to skip the host element
                        handleFocus(this);
                    }
                    return;
                }
                // NOTE: Technically this should be `super.tabIndex` however Typescript
                // has a known bug while transpiling down to ES5
                // https://github.com/Microsoft/TypeScript/issues/338
                const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                descriptor.set.call(this, value);
            }
            blur() {
                if (hasSyntheticShadow(this) && isDelegatingFocus(this)) {
                    const currentActiveElement = getActiveElement(this);
                    if (!isNull(currentActiveElement)) {
                        // if there is an active element, blur it
                        currentActiveElement.blur();
                        return;
                    }
                }
                // NOTE: Technically this should be `super.blur` however Typescript
                // has a known bug while transpiling down to ES5
                // https://github.com/Microsoft/TypeScript/issues/338
                return superBlur.call(this);
            }
            focus() {
                disableKeyboardFocusNavigationRoutines();
                // TODO: #1327 - Shadow DOM semantics for focus method
                superFocus.call(this);
                enableKeyboardFocusNavigationRoutines();
            }
            get childNodes() {
                if (hasSyntheticShadow(this)) {
                    const owner = getNodeOwner(this);
                    const childNodes = isNull(owner)
                        ? []
                        : getAllMatches(owner, getFilteredChildNodes(this));
                    if (isFalse(hasNativeSymbolsSupport$1) &&
                        isExternalChildNodeAccessorFlagOn()) {
                        // inserting a comment node as the first childNode to trick the IE11
                        // DevTool to show the content of the shadowRoot, this should only happen
                        // in dev-mode and in IE11 (which we detect by looking at the symbol).
                        // Plus it should only be in place if we know it is an external invoker.
                        ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
                    }
                    return createStaticNodeList(childNodes);
                }
                // nothing to do here since this does not have a synthetic shadow attached to it
                return childNodesGetter.call(this);
            }
            get children() {
                if (hasSyntheticShadow(this)) {
                    const owner = getNodeOwner(this);
                    const childNodes = isNull(owner)
                        ? []
                        : getAllMatches(owner, getFilteredChildNodes(this));
                    return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));
                }
                // nothing to do here since this does not have a synthetic shadow attached to it
                return childrenGetter.call(this);
            }
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // We can use a single observer without having to worry about leaking because
    // "Registered observers in a nodes registered observer list have a weak
    // reference to the node."
    // https://dom.spec.whatwg.org/#garbage-collection
    let observer;
    const observerConfig = { childList: true };
    const SlotChangeKey = createFieldName('slotchange');
    function initSlotObserver() {
        return new MutationObserver(mutations => {
            const slots = [];
            forEach.call(mutations, mutation => {
                {
                    assert.isTrue(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
                }
                const { target: slot } = mutation;
                if (ArrayIndexOf.call(slots, slot) === -1) {
                    ArrayPush.call(slots, slot);
                    dispatchEvent.call(slot, new CustomEvent('slotchange'));
                }
            });
        });
    }
    function getFilteredSlotAssignedNodes(slot) {
        const owner = getNodeOwner(slot);
        if (isNull(owner)) {
            return [];
        }
        const childNodes = collectionSlice(childNodesGetter.call(slot));
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        return ArrayReduce.call(childNodes, (seed, child) => {
            if (!isNodeOwnedBy(owner, child)) {
                ArrayPush.call(seed, child);
            }
            return seed;
        }, []);
    }
    function getFilteredSlotFlattenNodes(slot) {
        const childNodes = collectionSlice(childNodesGetter.call(slot));
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        return ArrayReduce.call(childNodes, (seed, child) => {
            if (child instanceof Element && isSlotElement(child)) {
                ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
            }
            else {
                ArrayPush.call(seed, child);
            }
            return seed;
        }, []);
    }
    function PatchedSlotElement(elm) {
        const Ctor = PatchedElement(elm);
        const { addEventListener: superAddEventListener } = elm;
        return class PatchedHTMLSlotElement extends Ctor {
            addEventListener(type, listener, options) {
                if (type === 'slotchange' && !getInternalField(this, SlotChangeKey)) {
                    setInternalField(this, SlotChangeKey, true);
                    if (!observer) {
                        observer = initSlotObserver();
                    }
                    MutationObserverObserve.call(observer, this, observerConfig);
                }
                superAddEventListener.call(this, type, listener, options);
            }
            assignedElements(options) {
                const flatten = !isUndefined(options) && isTrue(options.flatten);
                const nodes = flatten
                    ? getFilteredSlotFlattenNodes(this)
                    : getFilteredSlotAssignedNodes(this);
                return ArrayFilter.call(nodes, node => node instanceof Element);
            }
            assignedNodes(options) {
                const flatten = !isUndefined(options) && isTrue(options.flatten);
                return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
            }
            get name() {
                // in browsers that do not support shadow dom, slot's name attribute is not reflective
                const name = getAttribute.call(this, 'name');
                return isNull(name) ? '' : name;
            }
            get childNodes() {
                const owner = getNodeOwner(this);
                const childNodes = isNull(owner)
                    ? []
                    : getAllMatches(owner, getFilteredChildNodes(this));
                return createStaticNodeList(childNodes);
            }
            get children() {
                const owner = getNodeOwner(this);
                const childNodes = isNull(owner)
                    ? []
                    : getAllMatches(owner, getFilteredChildNodes(this));
                return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));
            }
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Extract the patched getRootNode
    const { getRootNode: patchedGetRootNode$1 } = Node.prototype;
    function getNodeOwner(node) {
        if (!(node instanceof Node)) {
            return null;
        }
        const ownerKey = getNodeNearestOwnerKey(node);
        if (isUndefined(ownerKey)) {
            return null;
        }
        let nodeOwner = node;
        // At this point, node is a valid node with owner identity, now we need to find the owner node
        // search for a custom element with a VM that owns the first element with owner identity attached to it
        while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
            nodeOwner = parentNodeGetter.call(nodeOwner);
        }
        if (isNull(nodeOwner)) {
            return null;
        }
        return nodeOwner;
    }
    function isSlotElement(elm) {
        return tagNameGetter.call(elm) === 'SLOT';
    }
    function isNodeOwnedBy(owner, node) {
        {
            assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
            assert.invariant(node instanceof Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
            assert.isTrue(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
        }
        const ownerKey = getNodeNearestOwnerKey(node);
        return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
    }
    function shadowRootChildNodes(root) {
        const elm = getHost(root);
        return getAllMatches(elm, childNodesGetter.call(elm));
    }
    function getAllMatches(owner, nodeList) {
        const filteredAndPatched = [];
        for (let i = 0, len = nodeList.length; i < len; i += 1) {
            const node = nodeList[i];
            const isOwned = isNodeOwnedBy(owner, node);
            if (isOwned) {
                // Patch querySelector, querySelectorAll, etc
                // if element is owned by VM
                ArrayPush.call(filteredAndPatched, node);
            }
        }
        return filteredAndPatched;
    }
    function getFirstMatch(owner, nodeList) {
        for (let i = 0, len = nodeList.length; i < len; i += 1) {
            if (isNodeOwnedBy(owner, nodeList[i])) {
                return nodeList[i];
            }
        }
        return null;
    }
    function shadowRootQuerySelector(root, selector) {
        const elm = getHost(root);
        const nodeList = querySelectorAll$1.call(elm, selector);
        return getFirstMatch(elm, nodeList);
    }
    function shadowRootQuerySelectorAll(root, selector) {
        const elm = getHost(root);
        const nodeList = querySelectorAll$1.call(elm, selector);
        return getAllMatches(elm, nodeList);
    }
    function getFilteredChildNodes(node) {
        let children;
        if (!isUndefined(getNodeKey(node))) {
            // node itself is a custom element
            // lwc element, in which case we need to get only the nodes
            // that were slotted
            const slots = querySelectorAll$1.call(node, 'slot');
            children = ArrayReduce.call(slots, (seed, slot) => {
                if (isNodeOwnedBy(node, slot)) {
                    ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
                }
                return seed;
            }, []);
        }
        else {
            // regular element
            children = childNodesGetter.call(node);
        }
        const owner = getNodeOwner(node);
        if (isNull(owner)) {
            return [];
        }
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        return ArrayReduce.call(children, (seed, child) => {
            if (isNodeOwnedBy(owner, child)) {
                ArrayPush.call(seed, child);
            }
            return seed;
        }, []);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // DO NOT CHANGE this:
    // these two values need to be in sync with engine
    const OwnerKey = '$$OwnerKey$$';
    const OwnKey = '$$OwnKey$$';
    const hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
    function getNodeOwnerKey(node) {
        return node[OwnerKey];
    }
    function setNodeOwnerKey(node, value) {
        {
            // in dev-mode, we are more restrictive about what you can do with the owner key
            defineProperty(node, OwnerKey, {
                value,
                configurable: true,
            });
        }
    }
    function setNodeKey(node, value) {
        {
            // in dev-mode, we are more restrictive about what you can do with the own key
            defineProperty(node, OwnKey, {
                value,
            });
        }
    }
    function getNodeNearestOwnerKey(node) {
        let ownerNode = node;
        let ownerKey;
        // search for the first element with owner identity (just in case of manually inserted elements)
        while (!isNull(ownerNode)) {
            ownerKey = ownerNode[OwnerKey];
            if (!isUndefined(ownerKey)) {
                return ownerKey;
            }
            ownerNode = parentNodeGetter.call(ownerNode);
        }
    }
    function getNodeKey(node) {
        return node[OwnKey];
    }
    function isNodeShadowed(node) {
        return !isUndefined(getNodeNearestOwnerKey(node));
    }
    function getShadowParent(node, value) {
        const owner = getNodeOwner(node);
        if (value === owner) {
            // walking up via parent chain might end up in the shadow root element
            return getShadowRoot(owner);
        }
        else if (value instanceof Element) {
            if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
                // the element and its parent node belong to the same shadow root
                return value;
            }
            else if (!isNull(owner) && isSlotElement(value)) {
                // slotted elements must be top level childNodes of the slot element
                // where they slotted into, but its shadowed parent is always the
                // owner of the slot.
                const slotOwner = getNodeOwner(value);
                if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
                    // it is a slotted element, and therefore its parent is always going to be the host of the slot
                    return slotOwner;
                }
            }
        }
        return null;
    }
    function PatchedNode(node) {
        const Ctor = getPrototypeOf(node).constructor;
        class PatchedNodeClass {
            constructor() {
                // Patched classes are not supposed to be instantiated directly, ever!
                throw new TypeError('Illegal constructor');
            }
            hasChildNodes() {
                return getInternalChildNodes(this).length > 0;
            }
            get firstChild() {
                const childNodes = getInternalChildNodes(this);
                return childNodes[0] || null;
            }
            get lastChild() {
                const childNodes = getInternalChildNodes(this);
                return childNodes[childNodes.length - 1] || null;
            }
            get textContent() {
                return getTextContent(this);
            }
            set textContent(value) {
                textContextSetter.call(this, value);
            }
            get childElementCount() {
                return this.children.length;
            }
            get firstElementChild() {
                return this.children[0] || null;
            }
            get lastElementChild() {
                const { children } = this;
                return children.item(children.length - 1) || null;
            }
            get assignedSlot() {
                const parentNode = parentNodeGetter.call(this);
                /**
                 * if it doesn't have a parent node,
                 * or the parent is not an slot element
                 * or they both belong to the same template (default content)
                 * we should assume that it is not slotted
                 */
                if (isNull(parentNode) ||
                    !isSlotElement(parentNode) ||
                    getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
                    return null;
                }
                return parentNode;
            }
            get parentNode() {
                const value = parentNodeGetter.call(this);
                if (isNull(value)) {
                    return value;
                }
                return getShadowParent(this, value);
            }
            get parentElement() {
                const value = parentNodeGetter.call(this);
                if (isNull(value)) {
                    return null;
                }
                const parentNode = getShadowParent(this, value);
                // it could be that the parentNode is the shadowRoot, in which case
                // we need to return null.
                return parentNode instanceof Element ? parentNode : null;
            }
            compareDocumentPosition(otherNode) {
                if (patchedGetRootNode$1.call(this) === otherNode) {
                    // "this" is in a shadow tree where the shadow root is the "otherNode".
                    return 10; // Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING
                }
                else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                    // "this" and "otherNode" belongs to 2 different shadow tree.
                    return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING
                }
                // Since "this" and "otherNode" are part of the same shadow tree we can safely rely to the native
                // Node.compareDocumentPosition implementation.
                return compareDocumentPosition.call(this, otherNode);
            }
            contains(otherNode) {
                if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                    // it is from another shadow
                    return false;
                }
                return ((compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                    0);
            }
            cloneNode(deep) {
                const clone = cloneNode.call(this, false);
                // Per spec, browsers only care about truthy values
                // Not strict true or false
                if (!deep) {
                    return clone;
                }
                const childNodes = getInternalChildNodes(this);
                for (let i = 0, len = childNodes.length; i < len; i += 1) {
                    clone.appendChild(childNodes[i].cloneNode(true));
                }
                return clone;
            }
        }
        // prototype inheritance dance
        setPrototypeOf(PatchedNodeClass, Ctor);
        setPrototypeOf(PatchedNodeClass.prototype, Ctor.prototype);
        return PatchedNodeClass;
    }
    let internalChildNodeAccessorFlag = false;
    /**
     * These 2 methods are providing a machinery to understand who is accessing the
     * .childNodes member property of a node. If it is used from inside the synthetic shadow
     * or from an external invoker. This helps to produce the right output in one very peculiar
     * case, the IE11 debugging comment for shadowRoot representation on the devtool.
     */
    function isExternalChildNodeAccessorFlagOn() {
        return !internalChildNodeAccessorFlag;
    }
    const getInternalChildNodes = isFalse(hasNativeSymbolsSupport$1)
        ? function (node) {
            internalChildNodeAccessorFlag = true;
            let childNodes;
            let error = null;
            try {
                childNodes = node.childNodes;
            }
            catch (e) {
                // childNodes accessor should never throw, but just in case!
                error = e;
            }
            finally {
                internalChildNodeAccessorFlag = false;
                if (!isNull(error)) {
                    // re-throwing after restoring the state machinery for setInternalChildNodeAccessorFlag
                    throw error; // eslint-disable-line no-unsafe-finally
                }
            }
            return childNodes;
        }
        : function (node) {
            return node.childNodes;
        };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let skipGlobalPatching;
    function isGlobalPatchingSkipped(node) {
        if (isUndefined(skipGlobalPatching)) {
            const ownerDocument = getOwnerDocument(node);
            skipGlobalPatching =
                ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
        }
        return isTrue(skipGlobalPatching);
    }
    function apply$2() {
        function elemFromPoint(left, top) {
            const element = elementFromPoint.call(this, left, top);
            if (isNull(element)) {
                return element;
            }
            return retarget(this, pathComposer(element, true));
        }
        // https://github.com/Microsoft/TypeScript/issues/14139
        Document.prototype.elementFromPoint = elemFromPoint;
        // Go until we reach to top of the LWC tree
        defineProperty(Document.prototype, 'activeElement', {
            get() {
                let node = DocumentPrototypeActiveElement.call(this);
                if (isNull(node)) {
                    return node;
                }
                while (!isUndefined(getNodeOwnerKey(node))) {
                    node = parentElementGetter.call(node);
                    if (isNull(node)) {
                        return null;
                    }
                }
                if (node.tagName === 'HTML') {
                    // IE 11. Active element should never be html element
                    node = this.body;
                }
                return node;
            },
            enumerable: true,
            configurable: true,
        });
        // The following patched methods hide shadowed elements from global
        // traversing mechanisms. They are simplified for performance reasons to
        // filter by ownership and do not account for slotted elements. This
        // compromise is fine for our synthetic shadow dom because root elements
        // cannot have slotted elements.
        // Another compromise here is that all these traversing methods will return
        // static HTMLCollection or static NodeList. We decided that this compromise
        // is not a big problem considering the amount of code that is relying on
        // the liveliness of these results are rare.
        defineProperty(Document.prototype, 'getElementById', {
            value() {
                const elm = getElementById.apply(this, ArraySlice.call(arguments));
                if (isNull(elm)) {
                    return null;
                }
                return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'querySelector', {
            value() {
                const elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
                const filtered = collectionFind(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
                return !isUndefined(filtered) ? filtered : null;
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'querySelectorAll', {
            value() {
                const elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
                const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
                return createStaticNodeList(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'getElementsByClassName', {
            value() {
                const elements = getElementsByClassName.apply(this, ArraySlice.call(arguments));
                const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'getElementsByTagName', {
            value() {
                const elements = getElementsByTagName.apply(this, ArraySlice.call(arguments));
                const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'getElementsByTagNameNS', {
            value() {
                const elements = getElementsByTagNameNS.apply(this, ArraySlice.call(arguments));
                const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(
        // In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype
        getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName')
            ? HTMLDocument.prototype
            : Document.prototype, 'getElementsByName', {
            value() {
                const elements = getElementsByName.apply(this, ArraySlice.call(arguments));
                const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
                return createStaticNodeList(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$2();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let skipGlobalPatching$1;
    function isGlobalPatchingSkipped$1(node) {
        if (isUndefined(skipGlobalPatching$1)) {
            const ownerDocument = getOwnerDocument(node);
            skipGlobalPatching$1 =
                ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
        }
        return isTrue(skipGlobalPatching$1);
    }
    function apply$3() {
        const HTMLBodyElementPrototype = HTMLBodyElement.prototype;
        // The following patched methods hide shadowed elements from global
        // traversing mechanisms. They are simplified for performance reasons to
        // filter by ownership and do not account for slotted elements. This
        // compromise is fine for our synthetic shadow dom because root elements
        // cannot have slotted elements.
        // Another compromise here is that all these traversing methods will return
        // static HTMLCollection or static NodeList. We decided that this compromise
        // is not a big problem considering the amount of code that is relying on
        // the liveliness of these results are rare.
        defineProperty(HTMLBodyElementPrototype, 'querySelector', {
            value() {
                const elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
                const ownerKey = getNodeOwnerKey(this);
                // Return the first non shadow element
                const filtered = collectionFind(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
                return !isUndefined(filtered) ? filtered : null;
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'querySelectorAll', {
            value() {
                const elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
                const ownerKey = getNodeOwnerKey(this);
                const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
                return createStaticNodeList(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'getElementsByClassName', {
            value() {
                const elements = getElementsByClassName$1.apply(this, ArraySlice.call(arguments));
                const ownerKey = getNodeOwnerKey(this);
                const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'getElementsByTagName', {
            value() {
                const elements = getElementsByTagName$1.apply(this, ArraySlice.call(arguments));
                const ownerKey = getNodeOwnerKey(this);
                const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'getElementsByTagNameNS', {
            value() {
                const elements = getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments));
                const ownerKey = getNodeOwnerKey(this);
                const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$3();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$4() {
        Object.defineProperty(window, 'ShadowRoot', {
            value: SyntheticShadowRoot,
            configurable: true,
            writable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$4();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
    function detect() {
        if (!composedDescriptor) {
            // No need to apply this polyfill if this client completely lacks
            // support for the composed property.
            return false;
        }
        // Assigning a throwaway click event here to suppress a ts error when we
        // pass clickEvent into the composed getter below. The error is:
        // [ts] Variable 'clickEvent' is used before being assigned.
        let clickEvent = new Event('click');
        const button = document.createElement('button');
        button.addEventListener('click', event => (clickEvent = event));
        button.click();
        return !composedDescriptor.get.call(clickEvent);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');
    function handleClick(event) {
        Object.defineProperty(event, 'composed', {
            configurable: true,
            enumerable: true,
            get() {
                return true;
            },
        });
    }
    function apply$5() {
        HTMLElement.prototype.click = function () {
            addEventListener.call(this, 'click', handleClick);
            try {
                originalClickDescriptor.value.call(this);
            }
            finally {
                removeEventListener.call(this, 'click', handleClick);
            }
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect()) {
        apply$5();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$1() {
        return Object.getOwnPropertyDescriptor(Event.prototype, 'composed') === undefined;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$6() {
        // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937
        const composedEvents = assign(create(null), {
            blur: 1,
            focus: 1,
            focusin: 1,
            focusout: 1,
            click: 1,
            dblclick: 1,
            mousedown: 1,
            mouseenter: 1,
            mouseleave: 1,
            mousemove: 1,
            mouseout: 1,
            mouseover: 1,
            mouseup: 1,
            wheel: 1,
            beforeinput: 1,
            input: 1,
            keydown: 1,
            keyup: 1,
            compositionstart: 1,
            compositionupdate: 1,
            compositionend: 1,
            touchstart: 1,
            touchend: 1,
            touchmove: 1,
            touchcancel: 1,
            pointerover: 1,
            pointerenter: 1,
            pointerdown: 1,
            pointermove: 1,
            pointerup: 1,
            pointercancel: 1,
            pointerout: 1,
            pointerleave: 1,
            gotpointercapture: 1,
            lostpointercapture: 1,
            dragstart: 1,
            drag: 1,
            dragenter: 1,
            dragleave: 1,
            dragover: 1,
            drop: 1,
            dragend: 1,
            DOMActivate: 1,
            DOMFocusIn: 1,
            DOMFocusOut: 1,
            keypress: 1,
        });
        // Composed for Native events
        Object.defineProperties(Event.prototype, {
            composed: {
                get() {
                    const { type } = this;
                    return composedEvents[type] === 1;
                },
                configurable: true,
                enumerable: true,
            },
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect$1()) {
        apply$6();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { CustomEvent: OriginalCustomEvent } = window;
    function PatchedCustomEvent(type, eventInitDict) {
        const event = new OriginalCustomEvent(type, eventInitDict);
        // support for composed on custom events
        Object.defineProperties(event, {
            composed: {
                // We can't use "value" here, because IE11 doesn't like mixing and matching
                // value with get() from Event.prototype.
                get() {
                    return !!(eventInitDict && eventInitDict.composed);
                },
                configurable: true,
                enumerable: true,
            },
        });
        return event;
    }
    function apply$7() {
        window.CustomEvent = PatchedCustomEvent;
        window.CustomEvent.prototype = OriginalCustomEvent.prototype;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$7();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$8 () {
        const originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed')
            .get;
        Object.defineProperties(FocusEvent.prototype, {
            composed: {
                get() {
                    const { isTrusted } = this;
                    const composed = originalComposedGetter.call(this);
                    if (isTrusted && composed === false) {
                        return true;
                    }
                    return composed;
                },
                enumerable: true,
                configurable: true,
            },
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$8();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$2() {
        // Note: when using this in mobile apps, we might have a DOM that does not support iframes.
        return typeof HTMLIFrameElement !== 'undefined';
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$9() {
        // the iframe property descriptor for `contentWindow` should always be available, otherwise this method should never be called
        const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
        const { get: originalGetter } = desc;
        desc.get = function () {
            const original = originalGetter.call(this);
            // If the original iframe element is not a keyed node, then do not wrap it
            if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
                return original;
            }
            // only if the element is an iframe inside a shadowRoot, we care about this problem
            // because in that case, the code that is accessing the iframe, is very likely code
            // compiled with proxy-compat transformation. It is true that other code without those
            // transformations might also access an iframe from within a shadowRoot, but in that,
            // case, which is more rare, we still return the wrapper, and it should work the same,
            // this part is just an optimization.
            return wrapIframeWindow(original);
        };
        defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
    }
    function wrapIframeWindow(win) {
        return {
            addEventListener() {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.addEventListener.apply(win, arguments);
            },
            blur() {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.blur.apply(win, arguments);
            },
            close() {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.close.apply(win, arguments);
            },
            focus() {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.focus.apply(win, arguments);
            },
            postMessage() {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.postMessage.apply(win, arguments);
            },
            removeEventListener() {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.removeEventListener.apply(win, arguments);
            },
            get closed() {
                return win.closed;
            },
            get frames() {
                return win.frames;
            },
            get length() {
                return win.length;
            },
            get location() {
                return win.location;
            },
            set location(value) {
                win.location = value;
            },
            get opener() {
                return win.opener;
            },
            get parent() {
                return win.parent;
            },
            get self() {
                return win.self;
            },
            get top() {
                return win.top;
            },
            get window() {
                return win.window;
            },
        }; // this is limited
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect$2()) {
        apply$9();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const OriginalMutationObserver = window.MutationObserver;
    const { disconnect: originalDisconnect, observe: originalObserve, takeRecords: originalTakeRecords, } = OriginalMutationObserver.prototype;
    // Internal fields to maintain relationships
    const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
    const observerLookupField = '$$lwcNodeObservers$$';
    const observerToNodesMap = new WeakMap();
    /**
     * Retarget the mutation record's target value to its shadowRoot
     * @param {MutationRecord} originalRecord
     */
    function retargetMutationRecord(originalRecord) {
        const { addedNodes, removedNodes, target, type } = originalRecord;
        const retargetedRecord = create(MutationRecord.prototype);
        defineProperties(retargetedRecord, {
            addedNodes: {
                get() {
                    return addedNodes;
                },
                enumerable: true,
                configurable: true,
            },
            removedNodes: {
                get() {
                    return removedNodes;
                },
                enumerable: true,
                configurable: true,
            },
            type: {
                get() {
                    return type;
                },
                enumerable: true,
                configurable: true,
            },
            target: {
                get() {
                    return target.shadowRoot;
                },
                enumerable: true,
                configurable: true,
            },
        });
        return retargetedRecord;
    }
    /**
     * Utility to identify if a target node is being observed by the given observer
     * Start at the current node, if the observer is registered to observe the current node, the mutation qualifies
     * @param {MutationObserver} observer
     * @param {Node} target
     */
    function isQualifiedObserver(observer, target) {
        let parentNode = target;
        while (!isNull(parentNode)) {
            const parentNodeObservers = parentNode[observerLookupField];
            if (!isUndefined(parentNodeObservers) &&
                (parentNodeObservers[0] === observer || // perf optimization to check for the first item is a match
                    ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
                return true;
            }
            parentNode = parentNode.parentNode;
        }
        return false;
    }
    /**
     * This function provides a shadow dom compliant filtered view of mutation records for a given observer.
     *
     * The key logic here is to determine if a given observer has been registered to observe any nodes
     * between the target node of a mutation record to the target's root node.
     * This function also retargets records when mutations occur directly under the shadow root
     * @param {MutationRecords[]} mutations
     * @param {MutationObserver} observer
     */
    function filterMutationRecords(mutations, observer) {
        return ArrayReduce.call(mutations, (filteredSet, record) => {
            const { target, addedNodes, removedNodes, type } = record;
            // If target is an lwc host,
            // Determine if the mutations affected the host or the shadowRoot
            // Mutations affecting host: changes to slot content
            // Mutations affecting shadowRoot: changes to template content
            if (type === 'childList' && !isUndefined(getNodeKey(target))) {
                // In case of added nodes, we can climb up the tree and determine eligibility
                if (addedNodes.length > 0) {
                    // Optimization: Peek in and test one node to decide if the MutationRecord qualifies
                    // The remaining nodes in this MutationRecord will have the same ownerKey
                    const sampleNode = addedNodes[0];
                    if (isQualifiedObserver(observer, sampleNode)) {
                        // If the target was being observed, then return record as-is
                        // this will be the case for slot content
                        if (target[observerLookupField] &&
                            (target[observerLookupField][0] === observer ||
                                ArrayIndexOf.call(target[observerLookupField], observer) !== -1)) {
                            ArrayPush.call(filteredSet, record);
                        }
                        else {
                            // else, must be observing the shadowRoot
                            ArrayPush.call(filteredSet, retargetMutationRecord(record));
                        }
                    }
                }
                else {
                    // In the case of removed nodes, climbing the tree is not an option as the nodes are disconnected
                    // We can only check if either the host or shadow root was observed and qualify the record
                    const shadowRoot = target.shadowRoot;
                    const sampleNode = removedNodes[0];
                    if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && // trickery: sampleNode is slot content
                        isQualifiedObserver(observer, target) // use target as a close enough reference to climb up
                    ) {
                        ArrayPush.call(filteredSet, record);
                    }
                    else if (shadowRoot &&
                        shadowRoot[observerLookupField] &&
                        (shadowRoot[observerLookupField][0] === observer ||
                            ArrayIndexOf.call(shadowRoot[observerLookupField], observer) !== -1)) {
                        ArrayPush.call(filteredSet, retargetMutationRecord(record));
                    }
                }
            }
            else {
                // Mutation happened under a root node(shadow root or document) and the decision is straighforward
                // Ascend the tree starting from target and check if observer is qualified
                if (isQualifiedObserver(observer, target)) {
                    ArrayPush.call(filteredSet, record);
                }
            }
            return filteredSet;
        }, []);
    }
    function getWrappedCallback(callback) {
        let wrappedCallback = callback[wrapperLookupField];
        if (isUndefined(wrappedCallback)) {
            wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
                // Filter mutation records
                const filteredRecords = filterMutationRecords(mutations, observer);
                // If not records are eligible for the observer, do not invoke callback
                if (filteredRecords.length === 0) {
                    return;
                }
                callback.call(observer, filteredRecords, observer);
            };
        }
        return wrappedCallback;
    }
    /**
     * Patched MutationObserver constructor.
     * 1. Wrap the callback to filter out MutationRecords based on dom ownership
     * 2. Add a property field to track all observed targets of the observer instance
     * @param {MutationCallback} callback
     */
    function PatchedMutationObserver(callback) {
        const wrappedCallback = getWrappedCallback(callback);
        const observer = new OriginalMutationObserver(wrappedCallback);
        return observer;
    }
    function patchedDisconnect() {
        originalDisconnect.call(this);
        // Clear the node to observer reference which is a strong references
        const observedNodes = observerToNodesMap.get(this);
        if (!isUndefined(observedNodes)) {
            forEach.call(observedNodes, observedNode => {
                const observers = observedNode[observerLookupField];
                if (!isUndefined(observers)) {
                    const index = ArrayIndexOf.call(observers, this);
                    if (index !== -1) {
                        ArraySplice.call(observers, index, 1);
                    }
                }
            });
            observedNodes.length = 0;
        }
    }
    /**
     * A single mutation observer can observe multiple nodes(target).
     * Maintain a list of all targets that the observer chooses to observe
     * @param {Node} target
     * @param {Object} options
     */
    function patchedObserve(target, options) {
        // Maintain a list of all observers that want to observe a node
        if (isUndefined(target[observerLookupField])) {
            defineProperty(target, observerLookupField, { value: [] });
        }
        // Same observer trying to observe the same node
        if (ArrayIndexOf.call(target[observerLookupField], this) === -1) {
            ArrayPush.call(target[observerLookupField], this);
        } // else There is more bookkeeping to do here https://dom.spec.whatwg.org/#dom-mutationobserver-observe Step #7
        // If the target is a SyntheticShadowRoot, observe the host since the shadowRoot is an empty documentFragment
        if (target instanceof SyntheticShadowRoot) {
            target = target.host;
        }
        // maintain a list of all nodes observed by this observer
        if (observerToNodesMap.has(this)) {
            const observedNodes = observerToNodesMap.get(this);
            if (ArrayIndexOf.call(observedNodes, target) === -1) {
                ArrayPush.call(observedNodes, target);
            }
        }
        else {
            observerToNodesMap.set(this, [target]);
        }
        return originalObserve.call(this, target, options);
    }
    /**
     * Patch the takeRecords() api to filter MutationRecords based on the observed targets
     */
    function patchedTakeRecords() {
        return filterMutationRecords(originalTakeRecords.call(this), this);
    }
    PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
    PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
    PatchedMutationObserver.prototype.observe = patchedObserve;
    PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
    function apply$a() {
        defineProperty(window, 'MutationObserver', {
            value: PatchedMutationObserver,
            configurable: true,
            writable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$a();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ShadowTokenPrivateKey = '$$ShadowTokenKey$$';
    function getShadowToken(node) {
        return node.$shadowToken$;
    }
    function setShadowToken(node, shadowToken) {
        node.$shadowToken$ = shadowToken;
    }
    /**
     * Patching Element.prototype.$shadowToken$ to mark elements a portal:
     *
     *  - we use a property to allow engines to set a custom attribute that should be
     *    placed into the element to sandbox the css rules defined for the template.
     *
     *  - this custom attribute must be unique.
     *
     **/
    defineProperty(Element.prototype, '$shadowToken$', {
        set(shadowToken) {
            const oldShadowToken = this[ShadowTokenPrivateKey];
            if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
                removeAttribute.call(this, oldShadowToken);
            }
            if (!isUndefined(shadowToken)) {
                setAttribute.call(this, shadowToken, '');
            }
            this[ShadowTokenPrivateKey] = shadowToken;
        },
        get() {
            return this[ShadowTokenPrivateKey];
        },
        configurable: true,
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const MutationObserver$1 = window.MutationObserver;
    const MutationObserverObserve$1 = MutationObserver$1.prototype.observe;
    const DomManualPrivateKey = '$$DomManualKey$$';
    // We can use a single observer without having to worry about leaking because
    // "Registered observers in a nodes registered observer list have a weak
    // reference to the node."
    // https://dom.spec.whatwg.org/#garbage-collection
    let portalObserver;
    const portalObserverConfig = {
        childList: true,
        subtree: true,
    };
    function adoptChildNode(node, fn, shadowToken) {
        if (getShadowRootResolver(node) === fn) {
            return; // nothing to do here, it is already correctly patched
        }
        setShadowRootResolver(node, fn);
        if (node instanceof Element) {
            setShadowToken(node, shadowToken);
            // recursively patching all children as well
            const childNodes = getInternalChildNodes(node);
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                const child = childNodes[i];
                adoptChildNode(child, fn, shadowToken);
            }
        }
    }
    function initPortalObserver() {
        return new MutationObserver$1(mutations => {
            forEach.call(mutations, mutation => {
                const { target: elm, addedNodes } = mutation;
                // the target of the mutation should always have a ShadowRootResolver attached to it
                const fn = getShadowRootResolver(elm);
                const shadowToken = getShadowToken(elm);
                for (let i = 0, len = addedNodes.length; i < len; i += 1) {
                    const node = addedNodes[i];
                    adoptChildNode(node, fn, shadowToken);
                }
            });
        });
    }
    function markElementAsPortal(elm) {
        if (isUndefined(portalObserver)) {
            portalObserver = initPortalObserver();
        }
        if (isUndefined(getShadowRootResolver(elm))) {
            // only an element from a within a shadowRoot should be used here
            throw new Error(`Invalid Element`);
        }
        // install mutation observer for portals
        MutationObserverObserve$1.call(portalObserver, elm, portalObserverConfig);
        // TODO: #1253 - optimization to synchronously adopt new child nodes added
        // to this elm, we can do that by patching the most common operations
        // on the node itself
    }
    /**
     * Patching Element.prototype.$domManual$ to mark elements as portal:
     *
     *  - we use a property to allow engines to signal that a particular element in
     *    a shadow supports manual insertion of child nodes.
     *
     *  - this signal comes as a boolean value, and we use it to install the MO instance
     *    onto the element, to propagate the $ownerKey$ and $shadowToken$ to all new
     *    child nodes.
     *
     *  - at the moment, there is no way to undo this operation, once the element is
     *    marked as $domManual$, setting it to false does nothing.
     *
     **/
    // TODO: #1306 - rename this to $observerConnection$
    defineProperty(Element.prototype, '$domManual$', {
        set(v) {
            this[DomManualPrivateKey] = v;
            if (isTrue(v)) {
                markElementAsPortal(this);
            }
        },
        get() {
            return this[DomManualPrivateKey];
        },
        configurable: true,
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    Element.prototype.$lwcPolyfill$ = {
        PatchedNode,
        PatchedElement,
        PatchedSlotElement,
    };

}));
/** version: 1.0.2-222.23 */
