/* proxy-compat-disable */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
    factory();
}(function () { 'use strict';

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create = Object.create, assign = Object.assign, defineProperty = Object.defineProperty, getPrototypeOf = Object.getPrototypeOf, setPrototypeOf = Object.setPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, defineProperties = Object.defineProperties, hasOwnProperty = Object.hasOwnProperty;
    var _a = Array.prototype, ArrayFilter = _a.filter, ArrayFind = _a.find, ArraySlice = _a.slice, ArraySplice = _a.splice, ArrayUnshift = _a.unshift, ArrayIndexOf = _a.indexOf, ArrayPush = _a.push, ArrayMap = _a.map, ArrayJoin = _a.join, forEach = _a.forEach, ArrayReduce = _a.reduce, ArrayReverse = _a.reverse;
    var _b = String.prototype, StringToLowerCase = _b.toLowerCase;
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }
    function isTrue(obj) {
        return obj === true;
    }
    function isFalse(obj) {
        return obj === false;
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    var OtS = {}.toString;
    function toString(obj) {
        if (obj && obj.toString) {
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS.call(obj);
        }
        else {
            return obj + '';
        }
    }
    function getPropertyDescriptor(o, p) {
        do {
            var d = getOwnPropertyDescriptor(o, p);
            if (!isUndefined(d)) {
                return d;
            }
            o = getPrototypeOf(o);
        } while (o !== null);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
    var elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint')
        ? Document.prototype.elementFromPoint
        : Document.prototype.msElementFromPoint; // IE11
    // defaultView can be null when a document has no browsing context. For example, the owner document
    // of a node in a template doesn't have a default view: https://jsfiddle.net/hv9z0q5a/
    var defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
    var _a$1 = Document.prototype, createComment = _a$1.createComment, querySelectorAll = _a$1.querySelectorAll, getElementById = _a$1.getElementById, getElementsByClassName = _a$1.getElementsByClassName, getElementsByTagName = _a$1.getElementsByTagName, getElementsByTagNameNS = _a$1.getElementsByTagNameNS;
    // In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype
    // In all other browsers have the method on Document.prototype
    var getElementsByName = HTMLDocument.prototype.getElementsByName;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var DOCUMENT_POSITION_CONTAINED_BY = Node.DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_CONTAINS = Node.DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING = Node.DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING, DOCUMENT_FRAGMENT_NODE = Node.DOCUMENT_FRAGMENT_NODE;
    var _a$2 = Node.prototype, appendChild = _a$2.appendChild, cloneNode = _a$2.cloneNode, compareDocumentPosition = _a$2.compareDocumentPosition, insertBefore = _a$2.insertBefore, removeChild = _a$2.removeChild, replaceChild = _a$2.replaceChild;
    var parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
    var ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
    var parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement')
        ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get; // IE11
    var textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
    var childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes')
        ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get; // IE11
    var isConnected = hasOwnProperty.call(Node.prototype, 'isConnected')
        ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get
        : function () {
            var doc = ownerDocumentGetter.call(this);
            // IE11
            return (
            // if doc is null, it means `this` is actually a document instance which
            // is always connected
            doc === null ||
                (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0);
        };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var _a$3 = Element.prototype, hasAttribute = _a$3.hasAttribute, getAttribute = _a$3.getAttribute, setAttribute = _a$3.setAttribute, removeAttribute = _a$3.removeAttribute, querySelectorAll$1 = _a$3.querySelectorAll, getBoundingClientRect = _a$3.getBoundingClientRect, getElementsByTagName$1 = _a$3.getElementsByTagName, getElementsByTagNameNS$1 = _a$3.getElementsByTagNameNS;
    var _b$1 = Element.prototype, addEventListener = _b$1.addEventListener, removeEventListener = _b$1.removeEventListener;
    var innerHTMLSetter = hasOwnProperty.call(Element.prototype, 'innerHTML')
        ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML').set; // IE11
    var outerHTMLSetter = hasOwnProperty.call(Element.prototype, 'outerHTML')
        ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML').set
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML').set; // IE11
    var tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
    var tabIndexGetter = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex').get;
    var matches = hasOwnProperty.call(Element.prototype, 'matches')
        ? Element.prototype.matches
        : Element.prototype.msMatchesSelector; // IE11
    var childrenGetter = hasOwnProperty.call(Element.prototype, 'children')
        ? getOwnPropertyDescriptor(Element.prototype, 'children').get
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get; // IE11
    // for IE11, access from HTMLElement
    // for all other browsers access the method from the parent Element interface
    var getElementsByClassName$1 = HTMLElement.prototype.getElementsByClassName;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ShadowRootHostGetter = typeof window.ShadowRoot !== 'undefined'
        ? getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'host').get
        : function () {
            throw new Error('Internal Error: Missing ShadowRoot');
        };
    var dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11
    var isNativeShadowRootAvailable = typeof window.ShadowRoot !== 'undefined';
    var eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
    var eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
    var focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLWC(element) {
        return element instanceof Element && tagNameGetter.call(element).indexOf('-') !== -1;
    }
    function isShadowRoot(elmOrShadow) {
        return !(elmOrShadow instanceof Element) && 'host' in elmOrShadow;
    }
    function getFormattedComponentStack(elm) {
        var componentStack = [];
        var indentationChar = '\t';
        var indentation = '';
        var currentElement = elm;
        do {
            if (isLWC(currentElement)) {
                ArrayPush.call(componentStack, indentation + "<" + StringToLowerCase.call(tagNameGetter.call(currentElement)) + ">");
                indentation = indentation + indentationChar;
            }
            if (isShadowRoot(currentElement)) {
                // if at some point we find a ShadowRoot, it must be a native shadow root.
                currentElement = ShadowRootHostGetter.call(currentElement);
            }
            else {
                currentElement = parentNodeGetter.call(currentElement);
            }
        } while (!isNull(currentElement));
        return ArrayJoin.call(componentStack, '\n');
    }
    var assert = {
        invariant: function (value, msg) {
            if (!value) {
                throw new Error("Invariant Violation: " + msg);
            }
        },
        isTrue: function (value, msg) {
            if (!value) {
                throw new Error("Assert Violation: " + msg);
            }
        },
        isFalse: function (value, msg) {
            if (value) {
                throw new Error("Assert Violation: " + msg);
            }
        },
        fail: function (msg) {
            throw new Error(msg);
        },
        logError: function (message, elm) {
            var msg = "[LWC error]: " + message;
            if (elm) {
                msg = msg + "\n" + getFormattedComponentStack(elm);
            }
            try {
                throw new Error(msg);
            }
            catch (e) {
                /* eslint-disable-next-line no-console */
                console.error(e);
            }
        },
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Helpful for tests running with jsdom
    function getOwnerDocument(node) {
        var doc = ownerDocumentGetter.call(node);
        // if doc is null, it means `this` is actually a document instance
        return doc === null ? node : doc;
    }
    function getOwnerWindow(node) {
        var doc = getOwnerDocument(node);
        var win = defaultViewGetter.call(doc);
        if (win === null) {
            // this method should never be called with a node that is not part
            // of a qualifying connected node.
            throw new TypeError();
        }
        return win;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    function pathComposer(startNode, composed) {
        var composedPath = [];
        var current = startNode;
        var startRoot = startNode instanceof Window ? startNode : patchedGetRootNode$1.call(startNode);
        while (current) {
            composedPath.push(current);
            if (current.assignedSlot) {
                current = current.assignedSlot;
            }
            else if (current.nodeType === DOCUMENT_FRAGMENT_NODE &&
                current.host &&
                (composed || current !== startRoot)) {
                current = current.host;
            }
            else {
                current = current.parentNode;
            }
        }
        var doc;
        if (startNode instanceof Window) {
            doc = startNode.document;
        }
        else {
            doc = getOwnerDocument(startNode);
        }
        // event composedPath includes window when startNode's ownerRoot is document
        if (composedPath[composedPath.length - 1] === doc) {
            composedPath.push(window);
        }
        return composedPath;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    function retarget(refNode, path) {
        if (isNull(refNode)) {
            return null;
        }
        // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
        // shadow-including inclusive ancestor, return ANCESTOR.
        var refNodePath = pathComposer(refNode, true);
        var p$ = path;
        for (var i = 0, ancestor = void 0, lastRoot = void 0, root = void 0, rootIdx = void 0; i < p$.length; i++) {
            ancestor = p$[i];
            root = ancestor instanceof Window ? ancestor : patchedGetRootNode$1.call(ancestor);
            if (root !== lastRoot) {
                rootIdx = refNodePath.indexOf(root);
                lastRoot = root;
            }
            if (!(root instanceof SyntheticShadowRoot) || rootIdx > -1) {
                return ancestor;
            }
        }
        return null;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var windowAddEventListener = window.addEventListener, windowRemoveEventListener = window.removeEventListener;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function doesEventNeedsPatch(e) {
        var originalTarget = eventTargetGetter.call(e);
        return originalTarget instanceof Node && isNodeShadowed(originalTarget);
    }
    function getEventListenerWrapper(fnOrObj) {
        var wrapperFn = null;
        try {
            wrapperFn = fnOrObj.$$lwcEventWrapper$$;
            if (!wrapperFn) {
                var isHandlerFunction_1 = typeof fnOrObj === 'function';
                wrapperFn = fnOrObj.$$lwcEventWrapper$$ = function (e) {
                    // we don't want to patch every event, only when the original target is coming
                    // from inside a synthetic shadow
                    if (doesEventNeedsPatch(e)) {
                        patchEvent(e);
                    }
                    return isHandlerFunction_1
                        ? fnOrObj.call(this, e)
                        : fnOrObj.handleEvent && fnOrObj.handleEvent(e);
                };
            }
        }
        catch (e) {
            /** ignore */
        }
        return wrapperFn;
    }
    function windowAddEventListener$1(type, fnOrObj, optionsOrCapture) {
        var handlerType = typeof fnOrObj;
        // bail if `fnOrObj` is not a function, not an object
        if (handlerType !== 'function' && handlerType !== 'object') {
            return;
        }
        // bail if `fnOrObj` is an object without a `handleEvent` method
        if (handlerType === 'object' &&
            (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
            return;
        }
        var wrapperFn = getEventListenerWrapper(fnOrObj);
        windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
    }
    function windowRemoveEventListener$1(type, fnOrObj, optionsOrCapture) {
        var wrapperFn = getEventListenerWrapper(fnOrObj);
        windowRemoveEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
    }
    function addEventListener$1(type, fnOrObj, optionsOrCapture) {
        var handlerType = typeof fnOrObj;
        // bail if `fnOrObj` is not a function, not an object
        if (handlerType !== 'function' && handlerType !== 'object') {
            return;
        }
        // bail if `fnOrObj` is an object without a `handleEvent` method
        if (handlerType === 'object' &&
            (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
            return;
        }
        var wrapperFn = getEventListenerWrapper(fnOrObj);
        addEventListener.call(this, type, wrapperFn, optionsOrCapture);
    }
    function removeEventListener$1(type, fnOrObj, optionsOrCapture) {
        var wrapperFn = getEventListenerWrapper(fnOrObj);
        removeEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
    }
    // TODO: #1305 - these patches should be on EventTarget.prototype instead of win and node protos
    function windowPatchListeners() {
        window.addEventListener = windowAddEventListener$1;
        window.removeEventListener = windowRemoveEventListener$1;
    }
    function nodePatchListeners() {
        Node.prototype.addEventListener = addEventListener$1;
        Node.prototype.removeEventListener = removeEventListener$1;
    }
    function apply() {
        windowPatchListeners();
        nodePatchListeners();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // intentionally extracting the patched addEventListener and removeEventListener from Node.prototype
    // due to the issues with JSDOM patching hazard.
    var _a$4 = Node.prototype, addEventListener$2 = _a$4.addEventListener, removeEventListener$2 = _a$4.removeEventListener;
    var EventListenerContext;
    (function (EventListenerContext) {
        EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
        EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
    })(EventListenerContext || (EventListenerContext = {}));
    var eventToContextMap = new WeakMap();
    function isChildNode(root, node) {
        return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
    }
    var GET_ROOT_NODE_CONFIG_FALSE = { composed: false };
    function getRootNodeHost(node, options) {
        var rootNode = patchedGetRootNode$1.call(node, options);
        // is SyntheticShadowRootInterface
        if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
            rootNode = getHost(rootNode);
        }
        return rootNode;
    }
    function targetGetter() {
        // currentTarget is always defined
        var originalCurrentTarget = eventCurrentTargetGetter.call(this);
        var originalTarget = eventTargetGetter.call(this);
        var composedPath = pathComposer(originalTarget, this.composed);
        var doc = getOwnerDocument(originalTarget);
        // Handle cases where the currentTarget is null (for async events),
        // and when an event has been added to Window
        if (!(originalCurrentTarget instanceof Node)) {
            // TODO: issue #1511 - Special escape hatch to support legacy behavior. Should be fixed.
            // If the event's target is being accessed async and originalTarget is not a keyed element, do not retarget
            if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
                return originalTarget;
            }
            return retarget(doc, composedPath);
        }
        else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
            // TODO: issue #1530 - If currentTarget is document or document.body (Third party libraries that have global event listeners)
            // and the originalTarget is not a keyed element, do not retarget
            if (isUndefined(getNodeOwnerKey(originalTarget))) {
                return originalTarget;
            }
            return retarget(doc, composedPath);
        }
        var eventContext = eventToContextMap.get(this);
        var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
            ? getShadowRoot(originalCurrentTarget)
            : originalCurrentTarget;
        return retarget(currentTarget, composedPath);
    }
    function composedPathValue() {
        var originalTarget = eventTargetGetter.call(this);
        return pathComposer(originalTarget, this.composed);
    }
    function patchEvent(event) {
        if (eventToContextMap.has(event)) {
            return; // already patched
        }
        defineProperties(event, {
            target: {
                get: targetGetter,
                enumerable: true,
                configurable: true,
            },
            composedPath: {
                value: composedPathValue,
                writable: true,
                enumerable: true,
                configurable: true,
            },
            // non-standard but important accessor
            srcElement: {
                get: targetGetter,
                enumerable: true,
                configurable: true,
            },
            path: {
                get: composedPathValue,
                enumerable: true,
                configurable: true,
            },
        });
        // not all events implement the relatedTarget getter, that's why we need to extract it from the instance
        // Note: we can't really use the super here because of issues with the typescript transpilation for accessors
        var originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');
        if (!isUndefined(originalRelatedTargetDescriptor)) {
            var relatedTargetGetter_1 = originalRelatedTargetDescriptor.get;
            defineProperty(event, 'relatedTarget', {
                get: function () {
                    var eventContext = eventToContextMap.get(this);
                    var originalCurrentTarget = eventCurrentTargetGetter.call(this);
                    var relatedTarget = relatedTargetGetter_1.call(this);
                    if (isNull(relatedTarget)) {
                        return null;
                    }
                    var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
                        ? getShadowRoot(originalCurrentTarget) /* because the context is a host */
                        : originalCurrentTarget;
                    return retarget(currentTarget, pathComposer(relatedTarget, true));
                },
                enumerable: true,
                configurable: true,
            });
        }
        eventToContextMap.set(event, 0);
    }
    var customElementToWrappedListeners = new WeakMap();
    function getEventMap(elm) {
        var listenerInfo = customElementToWrappedListeners.get(elm);
        if (isUndefined(listenerInfo)) {
            listenerInfo = create(null);
            customElementToWrappedListeners.set(elm, listenerInfo);
        }
        return listenerInfo;
    }
    var shadowRootEventListenerMap = new WeakMap();
    function getWrappedShadowRootListener(sr, listener) {
        if (!isFunction(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        var shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
        if (isUndefined(shadowRootWrappedListener)) {
            shadowRootWrappedListener = function (event) {
                // * if the event is dispatched directly on the host, it is not observable from root
                // * if the event is dispatched in an element that does not belongs to the shadow and it is not composed,
                //   it is not observable from the root
                var composed = event.composed;
                var target = eventTargetGetter.call(event);
                var currentTarget = eventCurrentTargetGetter.call(event);
                if (target !== currentTarget) {
                    var rootNode = getRootNodeHost(target /* because wrapping on shadowRoot */, {
                        composed: composed,
                    });
                    if (isChildNode(rootNode, currentTarget) ||
                        (composed === false && rootNode === currentTarget)) {
                        listener.call(sr, event);
                    }
                }
            };
            shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;
            {
                shadowRootWrappedListener.original = listener; // for logging purposes
            }
            shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
        }
        return shadowRootWrappedListener;
    }
    var customElementEventListenerMap = new WeakMap();
    function getWrappedCustomElementListener(elm, listener) {
        if (!isFunction(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        var customElementWrappedListener = customElementEventListenerMap.get(listener);
        if (isUndefined(customElementWrappedListener)) {
            customElementWrappedListener = function (event) {
                if (isValidEventForCustomElement(event)) {
                    // all handlers on the custom element should be called with undefined 'this'
                    listener.call(elm, event);
                }
            };
            customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;
            {
                customElementWrappedListener.original = listener; // for logging purposes
            }
            customElementEventListenerMap.set(listener, customElementWrappedListener);
        }
        return customElementWrappedListener;
    }
    function domListener(evt) {
        var immediatePropagationStopped = false;
        var propagationStopped = false;
        var type = evt.type, stopImmediatePropagation = evt.stopImmediatePropagation, stopPropagation = evt.stopPropagation;
        // currentTarget is always defined
        var currentTarget = eventCurrentTargetGetter.call(evt);
        var listenerMap = getEventMap(currentTarget);
        var listeners = listenerMap[type]; // it must have listeners at this point
        defineProperty(evt, 'stopImmediatePropagation', {
            value: function () {
                immediatePropagationStopped = true;
                stopImmediatePropagation.call(evt);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(evt, 'stopPropagation', {
            value: function () {
                propagationStopped = true;
                stopPropagation.call(evt);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        // in case a listener adds or removes other listeners during invocation
        var bookkeeping = ArraySlice.call(listeners);
        function invokeListenersByPlacement(placement) {
            forEach.call(bookkeeping, function (listener) {
                if (isFalse(immediatePropagationStopped) && listener.placement === placement) {
                    // making sure that the listener was not removed from the original listener queue
                    if (ArrayIndexOf.call(listeners, listener) !== -1) {
                        // all handlers on the custom element should be called with undefined 'this'
                        listener.call(undefined, evt);
                    }
                }
            });
        }
        eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
        invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);
        if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {
            // doing the second iteration only if the first one didn't interrupt the event propagation
            eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
            invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
        }
        eventToContextMap.set(evt, 0);
    }
    function attachDOMListener(elm, type, wrappedListener) {
        var listenerMap = getEventMap(elm);
        var cmpEventHandlers = listenerMap[type];
        if (isUndefined(cmpEventHandlers)) {
            cmpEventHandlers = listenerMap[type] = [];
        }
        // only add to DOM if there is no other listener on the same placement yet
        if (cmpEventHandlers.length === 0) {
            addEventListener$2.call(elm, type, domListener);
        }
        ArrayPush.call(cmpEventHandlers, wrappedListener);
    }
    function detachDOMListener(elm, type, wrappedListener) {
        var listenerMap = getEventMap(elm);
        var p;
        var listeners;
        if (!isUndefined((listeners = listenerMap[type])) &&
            (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
            ArraySplice.call(listeners, p, 1);
            // only remove from DOM if there is no other listener on the same placement
            if (listeners.length === 0) {
                removeEventListener$2.call(elm, type, domListener);
            }
        }
    }
    function isValidEventForCustomElement(event) {
        var target = eventTargetGetter.call(event);
        var currentTarget = eventCurrentTargetGetter.call(event);
        var composed = event.composed;
        return (
        // it is composed, and we should always get it, or
        composed === true ||
            // it is dispatched onto the custom element directly, or
            target === currentTarget ||
            // it is coming from a slotted element
            isChildNode(getRootNodeHost(target /* because wrap on shadowRoot */, GET_ROOT_NODE_CONFIG_FALSE), currentTarget));
    }
    function addCustomElementEventListener(elm, type, listener, options) {
        {
            assert.invariant(isFunction(listener), "Invalid second argument for this.addEventListener() in " + toString(elm) + " for event \"" + type + "\". Expected an EventListener but received " + listener + ".");
            // TODO: #420 - this is triggered when the component author attempts to add a listener
            // programmatically into a lighting element node
            if (!isUndefined(options)) {
                assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', elm);
            }
        }
        var wrappedListener = getWrappedCustomElementListener(elm, listener);
        attachDOMListener(elm, type, wrappedListener);
    }
    function removeCustomElementEventListener(elm, type, listener, _options) {
        var wrappedListener = getWrappedCustomElementListener(elm, listener);
        detachDOMListener(elm, type, wrappedListener);
    }
    function addShadowRootEventListener(sr, type, listener, options) {
        {
            assert.invariant(isFunction(listener), "Invalid second argument for this.template.addEventListener() in " + toString(sr) + " for event \"" + type + "\". Expected an EventListener but received " + listener + ".");
            // TODO: #420 - this is triggered when the component author attempts to add a listener
            // programmatically into its Component's shadow root
            if (!isUndefined(options)) {
                assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', getHost(sr));
            }
        }
        var elm = getHost(sr);
        var wrappedListener = getWrappedShadowRootListener(sr, listener);
        attachDOMListener(elm, type, wrappedListener);
    }
    function removeShadowRootEventListener(sr, type, listener, _options) {
        var elm = getHost(sr);
        var wrappedListener = getWrappedShadowRootListener(sr, listener);
        detachDOMListener(elm, type, wrappedListener);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
    function createFieldName(key) {
        // @ts-ignore: using a string as a symbol for perf reasons
        return hasNativeSymbolsSupport ? Symbol(key) : "$$lwc-" + key + "$$";
    }
    function setInternalField(o, fieldName, value) {
        // TODO: #1299 - improve this to use a WeakMap
        defineProperty(o, fieldName, {
            value: value,
        });
    }
    function getInternalField(o, fieldName) {
        return o[fieldName];
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getTextContent(node) {
        switch (node.nodeType) {
            case Node.ELEMENT_NODE: {
                var childNodes = getFilteredChildNodes(node);
                var content = '';
                for (var i = 0, len = childNodes.length; i < len; i += 1) {
                    content += getTextContent(childNodes[i]);
                }
                return content;
            }
            default:
                return node.nodeValue;
        }
    }

    var _a$5;
    var Items = createFieldName('items');
    function StaticNodeList() {
        throw new TypeError('Illegal constructor');
    }
    StaticNodeList.prototype = create(NodeList.prototype, (_a$5 = {
            constructor: {
                writable: true,
                configurable: true,
                value: StaticNodeList,
            },
            item: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function (index) {
                    return this[index];
                },
            },
            length: {
                enumerable: true,
                configurable: true,
                get: function () {
                    return getInternalField(this, Items).length;
                },
            },
            // Iterator protocol
            forEach: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function (cb, thisArg) {
                    forEach.call(getInternalField(this, Items), cb, thisArg);
                },
            },
            entries: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function () {
                    return ArrayMap.call(getInternalField(this, Items), function (v, i) { return [i, v]; });
                },
            },
            keys: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function () {
                    return ArrayMap.call(getInternalField(this, Items), function (v, i) { return i; });
                },
            },
            values: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function () {
                    return getInternalField(this, Items);
                },
            }
        },
        _a$5[Symbol.iterator] = {
            writable: true,
            configurable: true,
            value: function () {
                var _this = this;
                var nextIndex = 0;
                return {
                    next: function () {
                        var items = getInternalField(_this, Items);
                        return nextIndex < items.length
                            ? {
                                value: items[nextIndex++],
                                done: false,
                            }
                            : {
                                done: true,
                            };
                    },
                };
            },
        },
        _a$5[Symbol.toStringTag] = {
            configurable: true,
            get: function () {
                return 'NodeList';
            },
        },
        // IE11 doesn't support Symbol.toStringTag, in which case we
        // provide the regular toString method.
        _a$5.toString = {
            writable: true,
            configurable: true,
            value: function () {
                return '[object NodeList]';
            },
        },
        _a$5));
    // prototype inheritance dance
    setPrototypeOf(StaticNodeList, NodeList);
    function createStaticNodeList(items) {
        var nodeList = create(StaticNodeList.prototype);
        setInternalField(nodeList, Items, items);
        // setting static indexes
        forEach.call(items, function (item, index) {
            defineProperty(nodeList, index, {
                value: item,
                enumerable: true,
                configurable: true,
            });
        });
        return nodeList;
    }

    var _a$6;
    var Items$1 = createFieldName('items');
    function isValidHTMLCollectionName(name) {
        return name !== 'length' && isNaN(name);
    }
    function getNodeHTMLCollectionName(node) {
        return node.getAttribute('id') || node.getAttribute('name');
    }
    function StaticHTMLCollection() {
        throw new TypeError('Illegal constructor');
    }
    StaticHTMLCollection.prototype = create(HTMLCollection.prototype, (_a$6 = {
            constructor: {
                writable: true,
                configurable: true,
                value: StaticHTMLCollection,
            },
            item: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function (index) {
                    return this[index];
                },
            },
            length: {
                enumerable: true,
                configurable: true,
                get: function () {
                    return getInternalField(this, Items$1).length;
                },
            },
            // https://dom.spec.whatwg.org/#dom-htmlcollection-nameditem-key
            namedItem: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function (name) {
                    if (isValidHTMLCollectionName(name) && this[name]) {
                        return this[name];
                    }
                    var items = getInternalField(this, Items$1);
                    // Note: loop in reverse so that the first named item matches the named property
                    for (var len = items.length - 1; len >= 0; len -= 1) {
                        var item = items[len];
                        var nodeName = getNodeHTMLCollectionName(item);
                        if (nodeName === name) {
                            return item;
                        }
                    }
                    return null;
                },
            },
            // Iterator protocol
            forEach: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function (cb, thisArg) {
                    forEach.call(getInternalField(this, Items$1), cb, thisArg);
                },
            },
            entries: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function () {
                    return ArrayMap.call(getInternalField(this, Items$1), function (v, i) { return [i, v]; });
                },
            },
            keys: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function () {
                    return ArrayMap.call(getInternalField(this, Items$1), function (v, i) { return i; });
                },
            },
            values: {
                writable: true,
                enumerable: true,
                configurable: true,
                value: function () {
                    return getInternalField(this, Items$1);
                },
            }
        },
        _a$6[Symbol.iterator] = {
            writable: true,
            configurable: true,
            value: function () {
                var _this = this;
                var nextIndex = 0;
                return {
                    next: function () {
                        var items = getInternalField(_this, Items$1);
                        return nextIndex < items.length
                            ? {
                                value: items[nextIndex++],
                                done: false,
                            }
                            : {
                                done: true,
                            };
                    },
                };
            },
        },
        _a$6[Symbol.toStringTag] = {
            configurable: true,
            get: function () {
                return 'HTMLCollection';
            },
        },
        // IE11 doesn't support Symbol.toStringTag, in which case we
        // provide the regular toString method.
        _a$6.toString = {
            writable: true,
            configurable: true,
            value: function () {
                return '[object HTMLCollection]';
            },
        },
        _a$6));
    // prototype inheritance dance
    setPrototypeOf(StaticHTMLCollection, HTMLCollection);
    function createStaticHTMLCollection(items) {
        var collection = create(StaticHTMLCollection.prototype);
        setInternalField(collection, Items$1, items);
        // setting static indexes
        forEach.call(items, function (item, index) {
            defineProperty(collection, index, {
                value: item,
                enumerable: true,
                configurable: true,
            });
        });
        return collection;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getInnerHTML(node) {
        var s = '';
        var childNodes = getFilteredChildNodes(node);
        for (var i = 0, len = childNodes.length; i < len; i += 1) {
            s += getOuterHTML(childNodes[i]);
        }
        return s;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString
    var escapeAttrRegExp = /[&\u00A0"]/g;
    var escapeDataRegExp = /[&\u00A0<>]/g;
    var _a$7 = String.prototype, replace = _a$7.replace, toLowerCase = _a$7.toLowerCase;
    function escapeReplace(c) {
        switch (c) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '"':
                return '&quot;';
            case '\u00A0':
                return '&nbsp;';
            default:
                return '';
        }
    }
    function escapeAttr(s) {
        return replace.call(s, escapeAttrRegExp, escapeReplace);
    }
    function escapeData(s) {
        return replace.call(s, escapeDataRegExp, escapeReplace);
    }
    // http://www.whatwg.org/specs/web-apps/current-work/#void-elements
    var voidElements = new Set([
        'AREA',
        'BASE',
        'BR',
        'COL',
        'COMMAND',
        'EMBED',
        'HR',
        'IMG',
        'INPUT',
        'KEYGEN',
        'LINK',
        'META',
        'PARAM',
        'SOURCE',
        'TRACK',
        'WBR',
    ]);
    var plaintextParents = new Set([
        'STYLE',
        'SCRIPT',
        'XMP',
        'IFRAME',
        'NOEMBED',
        'NOFRAMES',
        'PLAINTEXT',
        'NOSCRIPT',
    ]);
    function getOuterHTML(node) {
        switch (node.nodeType) {
            case Node.ELEMENT_NODE: {
                var attrs = node.attributes;
                var tagName = tagNameGetter.call(node);
                var s = '<' + toLowerCase.call(tagName);
                for (var i = 0, attr = void 0; (attr = attrs[i]); i++) {
                    s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
                }
                s += '>';
                if (voidElements.has(tagName)) {
                    return s;
                }
                return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
            }
            case Node.TEXT_NODE: {
                var _a = node, data = _a.data, parentNode = _a.parentNode;
                if (parentNode instanceof Element &&
                    plaintextParents.has(tagNameGetter.call(parentNode))) {
                    return data;
                }
                return escapeData(data);
            }
            case Node.COMMENT_NODE: {
                return '<!--' + node.data + '-->';
            }
            default: {
                throw new Error();
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ShadowRootResolverKey = '$shadowResolver$';
    var InternalSlot = createFieldName('shadowRecord');
    var createDocumentFragment = document.createDocumentFragment;
    function getInternalSlot(root) {
        var record = getInternalField(root, InternalSlot);
        if (isUndefined(record)) {
            throw new TypeError();
        }
        return record;
    }
    var ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
    defineProperty(Node.prototype, ShadowRootResolverKey, {
        set: function (fn) {
            this[ShadowResolverPrivateKey] = fn;
            // TODO: #1164 - temporary propagation of the key
            setNodeOwnerKey(this, fn.nodeKey);
        },
        get: function () {
            return this[ShadowResolverPrivateKey];
        },
        configurable: true,
        enumerable: true,
    });
    function getShadowRootResolver(node) {
        return node[ShadowRootResolverKey];
    }
    function setShadowRootResolver(node, fn) {
        node[ShadowRootResolverKey] = fn;
    }
    function isDelegatingFocus(host) {
        return getInternalSlot(host).delegatesFocus;
    }
    function getHost(root) {
        return getInternalSlot(root).host;
    }
    function getShadowRoot(elm) {
        return getInternalSlot(elm).shadowRoot;
    }
    function hasSyntheticShadow(elm) {
        return !isUndefined(getInternalField(elm, InternalSlot));
    }
    var uid = 0;
    function attachShadow(elm, options) {
        if (!isUndefined(getInternalField(elm, InternalSlot))) {
            throw new Error("Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.");
        }
        var mode = options.mode, delegatesFocus = options.delegatesFocus;
        // creating a real fragment for shadowRoot instance
        var doc = getOwnerDocument(elm);
        var sr = createDocumentFragment.call(doc);
        // creating shadow internal record
        var record = {
            mode: mode,
            delegatesFocus: !!delegatesFocus,
            host: elm,
            shadowRoot: sr,
        };
        setInternalField(sr, InternalSlot, record);
        setInternalField(elm, InternalSlot, record);
        var shadowResolver = function () { return sr; };
        var x = (shadowResolver.nodeKey = uid++);
        setNodeKey(elm, x);
        setShadowRootResolver(sr, shadowResolver);
        // correcting the proto chain
        setPrototypeOf(sr, SyntheticShadowRoot.prototype);
        return sr;
    }
    var SyntheticShadowRootDescriptors = {
        constructor: {
            writable: true,
            configurable: true,
            value: SyntheticShadowRoot,
        },
        toString: {
            writable: true,
            configurable: true,
            value: function () {
                return "[object ShadowRoot]";
            },
        },
    };
    var ShadowRootDescriptors = {
        activeElement: {
            enumerable: true,
            configurable: true,
            get: function () {
                var host = getHost(this);
                var doc = getOwnerDocument(host);
                var activeElement = DocumentPrototypeActiveElement.call(doc);
                if (isNull(activeElement)) {
                    return activeElement;
                }
                if ((compareDocumentPosition.call(host, activeElement) &
                    DOCUMENT_POSITION_CONTAINED_BY) ===
                    0) {
                    return null;
                }
                // activeElement must be child of the host and owned by it
                var node = activeElement;
                while (!isNodeOwnedBy(host, node)) {
                    // parentElement is always an element because we are talking up the tree knowing
                    // that it is a child of the host.
                    node = parentElementGetter.call(node);
                }
                // If we have a slot element here that means that we were dealing
                // with an element that was passed to one of our slots. In this
                // case, activeElement returns null.
                if (isSlotElement(node)) {
                    return null;
                }
                return node;
            },
        },
        delegatesFocus: {
            configurable: true,
            get: function () {
                return getInternalSlot(this).delegatesFocus;
            },
        },
        elementFromPoint: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (left, top) {
                var host = getHost(this);
                var doc = getOwnerDocument(host);
                var element = elementFromPoint.call(doc, left, top);
                if (isNull(element)) {
                    return element;
                }
                return retarget(this, pathComposer(element, true));
            },
        },
        elementsFromPoint: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (_left, _top) {
                throw new Error();
            },
        },
        getSelection: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                throw new Error();
            },
        },
        host: {
            enumerable: true,
            configurable: true,
            get: function () {
                return getHost(this);
            },
        },
        mode: {
            configurable: true,
            get: function () {
                return getInternalSlot(this).mode;
            },
        },
        styleSheets: {
            enumerable: true,
            configurable: true,
            get: function () {
                throw new Error();
            },
        },
    };
    var NodePatchDescriptors = {
        insertBefore: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (newChild, refChild) {
                insertBefore.call(getHost(this), newChild, refChild);
                return newChild;
            },
        },
        removeChild: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (oldChild) {
                removeChild.call(getHost(this), oldChild);
                return oldChild;
            },
        },
        appendChild: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (newChild) {
                appendChild.call(getHost(this), newChild);
                return newChild;
            },
        },
        replaceChild: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (newChild, oldChild) {
                replaceChild.call(getHost(this), newChild, oldChild);
                return oldChild;
            },
        },
        addEventListener: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (type, listener, options) {
                addShadowRootEventListener(this, type, listener, options);
            },
        },
        removeEventListener: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (type, listener, options) {
                removeShadowRootEventListener(this, type, listener, options);
            },
        },
        baseURI: {
            enumerable: true,
            configurable: true,
            get: function () {
                return getHost(this).baseURI;
            },
        },
        childNodes: {
            enumerable: true,
            configurable: true,
            get: function () {
                return createStaticNodeList(shadowRootChildNodes(this));
            },
        },
        compareDocumentPosition: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (otherNode) {
                var host = getHost(this);
                if (this === otherNode) {
                    // "this" and "otherNode" are the same shadow root.
                    return 0;
                }
                else if (this.contains(otherNode)) {
                    // "otherNode" belongs to the shadow tree where "this" is the shadow root.
                    return 20; // Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING
                }
                else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
                    // "otherNode" is in a different shadow tree contained by the shadow tree where "this" is the shadow root.
                    return 37; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
                }
                else {
                    // "otherNode" is in a different shadow tree that is not contained by the shadow tree where "this" is the shadow root.
                    return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
                }
            },
        },
        contains: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (otherNode) {
                if (this === otherNode) {
                    return true;
                }
                var host = getHost(this);
                // must be child of the host and owned by it.
                return ((compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                    0 && isNodeOwnedBy(host, otherNode));
            },
        },
        firstChild: {
            enumerable: true,
            configurable: true,
            get: function () {
                var childNodes = getInternalChildNodes(this);
                return childNodes[0] || null;
            },
        },
        lastChild: {
            enumerable: true,
            configurable: true,
            get: function () {
                var childNodes = getInternalChildNodes(this);
                return childNodes[childNodes.length - 1] || null;
            },
        },
        hasChildNodes: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                var childNodes = getInternalChildNodes(this);
                return childNodes.length > 0;
            },
        },
        isConnected: {
            enumerable: true,
            configurable: true,
            get: function () {
                return isConnected.call(getHost(this));
            },
        },
        nextSibling: {
            enumerable: true,
            configurable: true,
            get: function () {
                return null;
            },
        },
        previousSibling: {
            enumerable: true,
            configurable: true,
            get: function () {
                return null;
            },
        },
        nodeName: {
            enumerable: true,
            configurable: true,
            get: function () {
                return '#document-fragment';
            },
        },
        nodeType: {
            enumerable: true,
            configurable: true,
            get: function () {
                return 11; // Node.DOCUMENT_FRAGMENT_NODE
            },
        },
        nodeValue: {
            enumerable: true,
            configurable: true,
            get: function () {
                return null;
            },
        },
        ownerDocument: {
            enumerable: true,
            configurable: true,
            get: function () {
                return getHost(this).ownerDocument;
            },
        },
        parentElement: {
            enumerable: true,
            configurable: true,
            get: function () {
                return null;
            },
        },
        parentNode: {
            enumerable: true,
            configurable: true,
            get: function () {
                return null;
            },
        },
        textContent: {
            enumerable: true,
            configurable: true,
            get: function () {
                var childNodes = getInternalChildNodes(this);
                var textContent = '';
                for (var i = 0, len = childNodes.length; i < len; i += 1) {
                    textContent += getTextContent(childNodes[i]);
                }
                return textContent;
            },
            set: function (v) {
                var host = getHost(this);
                textContextSetter.call(host, v);
            },
        },
        // Since the synthetic shadow root is a detached DocumentFragment, short-circuit the getRootNode behavior
        getRootNode: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (options) {
                return !isUndefined(options) && isTrue(options.composed)
                    ? getHost(this).getRootNode(options)
                    : this;
            },
        },
    };
    var ElementPatchDescriptors = {
        innerHTML: {
            enumerable: true,
            configurable: true,
            get: function () {
                var childNodes = getInternalChildNodes(this);
                var innerHTML = '';
                for (var i = 0, len = childNodes.length; i < len; i += 1) {
                    innerHTML += getOuterHTML(childNodes[i]);
                }
                return innerHTML;
            },
            set: function (v) {
                var host = getHost(this);
                innerHTMLSetter.call(host, v);
            },
        },
    };
    var ParentNodePatchDescriptors = {
        childElementCount: {
            enumerable: true,
            configurable: true,
            get: function () {
                return this.children.length;
            },
        },
        children: {
            enumerable: true,
            configurable: true,
            get: function () {
                return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), function (elm) { return elm instanceof Element; }));
            },
        },
        firstElementChild: {
            enumerable: true,
            configurable: true,
            get: function () {
                return this.children[0] || null;
            },
        },
        lastElementChild: {
            enumerable: true,
            configurable: true,
            get: function () {
                var children = this.children;
                return children.item(children.length - 1) || null;
            },
        },
        querySelector: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (selectors) {
                return shadowRootQuerySelector(this, selectors);
            },
        },
        querySelectorAll: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (selectors) {
                return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
            },
        },
    };
    assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
    function SyntheticShadowRoot() {
        throw new TypeError('Illegal constructor');
    }
    SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
    // Is native ShadowDom is available on window,
    // we need to make sure that our synthetic shadow dom
    // passed instanceof checks against window.ShadowDom
    if (isNativeShadowRootAvailable) {
        setPrototypeOf(SyntheticShadowRoot.prototype, window.ShadowRoot.prototype);
    }
    /**
     * This method is only intended to be used in non-production mode in IE11
     * and its role is to produce a 1-1 mapping between a shadowRoot instance
     * and a comment node that is intended to use to trick the IE11 DevTools
     * to show the content of the shadowRoot in the DOM Explorer.
     */
    function getIE11FakeShadowRootPlaceholder(host) {
        var shadowRoot = getShadowRoot(host);
        // @ts-ignore this $$placeholder$$ is not a security issue because you must
        // have access to the shadowRoot in order to extract the fake node, which give
        // you access to the same childNodes of the shadowRoot, so, who cares.
        var c = shadowRoot.$$placeholder$$;
        if (!isUndefined(c)) {
            return c;
        }
        var doc = getOwnerDocument(host);
        // @ts-ignore $$placeholder$$ is fine, read the node above.
        c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
        defineProperties(c, {
            childNodes: {
                get: function () {
                    return shadowRoot.childNodes;
                },
                enumerable: true,
                configurable: true,
            },
            tagName: {
                get: function () {
                    return "#shadow-root (" + shadowRoot.mode + ")";
                },
                enumerable: true,
                configurable: true,
            },
        });
        return c;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var MO = window.MutationObserver;
    // MutationObserver is not yet implemented in jsdom:
    // https://github.com/jsdom/jsdom/issues/639
    if (typeof MO === 'undefined') {
        /* eslint-disable-next-line no-inner-declarations */
        function MutationObserverMock() { }
        MutationObserverMock.prototype = {
            observe: function () {
                {
                    {
                        throw new Error("MutationObserver should not be mocked outside of the jest test environment");
                    }
                }
            },
        };
        MO = window.MutationObserver = MutationObserverMock;
    }
    var MutationObserver = MO;
    // Eventually, import the patched MutationObserver polyfill here
    // to ensure rest of the framework uses the patched version
    var MutationObserverObserve = MutationObserver.prototype.observe;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * Writing our own utils to handle NodeList and HTMLCollection. This is to not conflict with
     * some legacy third party libraries like prototype.js that patch Array.prototype.
     */
    /**
     * Custom implementation of filter since using Array.prototype.filter conflicts with other
     * legacy libraries like prototype.js
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Polyfill
     */
    function collectionFilter(collection, fn) {
        var res = [];
        var length = collection.length;
        for (var i = 0; i < length; i++) {
            var curr = collection[i];
            if (isTrue(fn(curr, i, collection))) {
                ArrayPush.call(res, curr);
            }
        }
        return res;
    }
    /**
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill
     */
    function collectionFind(collection, fn) {
        var length = collection.length;
        for (var i = 0; i < length; i++) {
            var curr = collection[i];
            if (isTrue(fn(curr, i, collection))) {
                return curr;
            }
        }
        return undefined;
    }
    /**
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Streamlining_cross-browser_behavior
     */
    function collectionSlice(collection, begin, end) {
        end = !isUndefined(end) ? end : collection.length;
        var cloned = [];
        var len = collection.length;
        // Handle negative value for "begin"
        var start = !isUndefined(begin) ? begin : 0;
        start = start >= 0 ? start : Math.max(0, len + start);
        // Handle negative value for "end"
        var upTo = !isUndefined(end) ? Math.min(end, len) : len;
        if (end < 0) {
            upTo = len + end;
        }
        // Actual expected size of the slice
        var size = upTo - start;
        if (size > 0) {
            for (var i = 0; i < size; i++) {
                ArrayPush.call(cloned, collection[start + i]);
            }
        }
        return cloned;
    }
    /**
     * Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
     */
    function collectionIndexOf(collection, searchItem, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        var len = collection.length;
        var i = Math.min(fromIndex, len);
        if (i < 0) {
            i = Math.max(0, len + i);
        }
        else if (i >= len) {
            return -1;
        }
        for (; i !== len; ++i) {
            if (collection[i] === searchItem) {
                return i;
            }
        }
        return -1;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var TabbableElementsQuery = "\n    button:not([tabindex=\"-1\"]):not([disabled]),\n    [contenteditable]:not([tabindex=\"-1\"]),\n    video[controls]:not([tabindex=\"-1\"]),\n    audio[controls]:not([tabindex=\"-1\"]),\n    [href]:not([tabindex=\"-1\"]),\n    input:not([tabindex=\"-1\"]):not([disabled]),\n    select:not([tabindex=\"-1\"]):not([disabled]),\n    textarea:not([tabindex=\"-1\"]):not([disabled]),\n    [tabindex=\"0\"]\n";
    var DidAddMouseDownListener = createFieldName('DidAddMouseDownListener');
    function isVisible(element) {
        var _a = getBoundingClientRect.call(element), width = _a.width, height = _a.height;
        var noZeroSize = width > 0 || height > 0;
        return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
    }
    // This function based on https://allyjs.io/data-tables/focusable.html
    // It won't catch everything, but should be good enough
    // There are a lot of edge cases here that we can't realistically handle
    // Determines if a particular element is tabbable, as opposed to simply focusable
    // Exported for jest purposes
    function isTabbable(element) {
        return matches.call(element, TabbableElementsQuery) && isVisible(element);
    }
    function getTabbableSegments(host) {
        var doc = getOwnerDocument(host);
        var all = querySelectorAll.call(doc, TabbableElementsQuery);
        var inner = collectionSlice(querySelectorAll$1.call(host, TabbableElementsQuery));
        {
            assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), "The focusin event is only relevant when the tabIndex property is -1 on the host.");
        }
        var firstChild = inner[0];
        var lastChild = inner[inner.length - 1];
        var hostIndex = collectionIndexOf(all, host);
        // Host element can show up in our "previous" section if its tabindex is 0
        // We want to filter that out here
        var firstChildIndex = hostIndex > -1 ? hostIndex : collectionIndexOf(all, firstChild);
        // Account for an empty inner list
        var lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : collectionIndexOf(all, lastChild) + 1;
        var prev = collectionSlice(all, 0, firstChildIndex);
        var next = collectionSlice(all, lastChildIndex);
        return {
            prev: prev,
            inner: inner,
            next: next,
        };
    }
    function getActiveElement(host) {
        var doc = getOwnerDocument(host);
        var activeElement = DocumentPrototypeActiveElement.call(doc);
        if (isNull(activeElement)) {
            return activeElement;
        }
        // activeElement must be child of the host and owned by it
        return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !==
            0
            ? activeElement
            : null;
    }
    function relatedTargetPosition(host, relatedTarget) {
        // assert: target must be child of host
        var pos = compareDocumentPosition.call(host, relatedTarget);
        if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
            // focus remains inside the host
            return 0;
        }
        else if (pos & DOCUMENT_POSITION_PRECEDING) {
            // focus is coming from above
            return 1;
        }
        else if (pos & DOCUMENT_POSITION_FOLLOWING) {
            // focus is coming from below
            return 2;
        }
        // we don't know what's going on.
        return -1;
    }
    function muteEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function muteFocusEventsDuringExecution(win, func) {
        windowAddEventListener.call(win, 'focusin', muteEvent, true);
        windowAddEventListener.call(win, 'focusout', muteEvent, true);
        func();
        windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
        windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
    }
    function focusOnNextOrBlur(segment, target, relatedTarget) {
        var win = getOwnerWindow(relatedTarget);
        var next = getNextTabbable(segment, relatedTarget);
        if (isNull(next)) {
            // nothing to focus on, blur to invalidate the operation
            muteFocusEventsDuringExecution(win, function () {
                target.blur();
            });
        }
        else {
            muteFocusEventsDuringExecution(win, function () {
                next.focus();
            });
        }
    }
    var letBrowserHandleFocus = false;
    function disableKeyboardFocusNavigationRoutines() {
        letBrowserHandleFocus = true;
    }
    function enableKeyboardFocusNavigationRoutines() {
        letBrowserHandleFocus = false;
    }
    function skipHostHandler(event) {
        if (letBrowserHandleFocus) {
            enableKeyboardFocusNavigationRoutines();
            return;
        }
        var host = eventCurrentTargetGetter.call(event);
        var target = eventTargetGetter.call(event);
        // If the host delegating focus with tabindex=0 is not the target, we know
        // that the event was dispatched on a descendant node of the host. This
        // means the focus is coming from below and we don't need to do anything.
        if (host !== target) {
            // Focus is coming from above
            return;
        }
        var relatedTarget = focusEventRelatedTargetGetter.call(event);
        if (isNull(relatedTarget)) {
            // If relatedTarget is null, the user is most likely tabbing into the document from the
            // browser chrome. We could probably deduce whether focus is coming in from the top or the
            // bottom by comparing the position of the target to all tabbable elements. This is an edge
            // case and only comes up if the custom element is the first or last tabbable element in the
            // document.
            return;
        }
        var segments = getTabbableSegments(host);
        var position = relatedTargetPosition(host, relatedTarget);
        if (position === 1) {
            // Focus is coming from above
            var findTabbableElms = isTabbableFrom.bind(null, patchedGetRootNode$1.call(host));
            var first_1 = ArrayFind.call(segments.inner, findTabbableElms);
            if (!isUndefined(first_1)) {
                var win = getOwnerWindow(first_1);
                muteFocusEventsDuringExecution(win, function () {
                    first_1.focus();
                });
            }
            else {
                focusOnNextOrBlur(segments.next, target, relatedTarget);
            }
        }
        else if (host === target) {
            // Host is receiving focus from below, either from its shadow or from a sibling
            focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
        }
    }
    function skipShadowHandler(event) {
        if (letBrowserHandleFocus) {
            enableKeyboardFocusNavigationRoutines();
            return;
        }
        var relatedTarget = focusEventRelatedTargetGetter.call(event);
        if (isNull(relatedTarget)) {
            // If relatedTarget is null, the user is most likely tabbing into the document from the
            // browser chrome. We could probably deduce whether focus is coming in from the top or the
            // bottom by comparing the position of the target to all tabbable elements. This is an edge
            // case and only comes up if the custom element is the first or last tabbable element in the
            // document.
            return;
        }
        var host = eventCurrentTargetGetter.call(event);
        var segments = getTabbableSegments(host);
        if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
            // If relatedTarget is contained by the host's subtree we can assume that the user is
            // tabbing between elements inside of the shadow. Do nothing.
            return;
        }
        var target = eventTargetGetter.call(event);
        // Determine where the focus is coming from (Tab or Shift+Tab)
        var position = relatedTargetPosition(host, relatedTarget);
        if (position === 1) {
            // Focus is coming from above
            focusOnNextOrBlur(segments.next, target, relatedTarget);
        }
        if (position === 2) {
            // Focus is coming from below
            focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
        }
    }
    // Use this function to determine whether you can start from one root and end up
    // at another element via tabbing.
    function isTabbableFrom(fromRoot, toElm) {
        if (!isTabbable(toElm)) {
            return false;
        }
        var ownerDocument = getOwnerDocument(toElm);
        var root = patchedGetRootNode$1.call(toElm);
        while (root !== ownerDocument && root !== fromRoot) {
            var sr = root;
            var host = sr.host;
            if (getAttribute.call(host, 'tabindex') === '-1') {
                return false;
            }
            root = host && patchedGetRootNode$1.call(host);
        }
        return true;
    }
    function getNextTabbable(tabbables, relatedTarget) {
        var len = tabbables.length;
        if (len > 0) {
            for (var i = 0; i < len; i += 1) {
                var next = tabbables[i];
                if (isTabbableFrom(patchedGetRootNode$1.call(relatedTarget), next)) {
                    return next;
                }
            }
        }
        return null;
    }
    // Skips the host element
    function handleFocus(elm) {
        {
            assert.invariant(isDelegatingFocus(elm), "Invalid attempt to handle focus event for " + toString(elm) + ". " + toString(elm) + " should have delegates focus true, but is not delegating focus");
        }
        bindDocumentMousedownMouseupHandlers(elm);
        // Unbind any focusin listeners we may have going on
        ignoreFocusIn(elm);
        addEventListener.call(elm, 'focusin', skipHostHandler, true);
    }
    function ignoreFocus(elm) {
        removeEventListener.call(elm, 'focusin', skipHostHandler, true);
    }
    function bindDocumentMousedownMouseupHandlers(elm) {
        var ownerDocument = getOwnerDocument(elm);
        if (!getInternalField(ownerDocument, DidAddMouseDownListener)) {
            setInternalField(ownerDocument, DidAddMouseDownListener, true);
            addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
            // Although our sequential focus navigation routines also unset this
            // flag, we need a backup plan in case they don't execute (e.g., the
            // click doesn't result in focus entering the shadow).
            addEventListener.call(ownerDocument, 'mouseup', function () {
                // We schedule this as an async task in the mouseup handler (as
                // opposed to the mousedown handler) because we want to guarantee
                // that it will never run before the focusin handler:
                //
                // Click form element   | Click form element label
                // ==================================================
                // mousedown            | mousedown
                // FOCUSIN              | mousedown-setTimeout
                // mousedown-setTimeout | mouseup
                // mouseup              | FOCUSIN
                // mouseup-setTimeout   | mouseup-setTimeout
                setTimeout(enableKeyboardFocusNavigationRoutines);
            }, true);
        }
    }
    // Skips the shadow tree
    function handleFocusIn(elm) {
        {
            assert.invariant(tabIndexGetter.call(elm) === -1, "Invalid attempt to handle focus in  " + toString(elm) + ". " + toString(elm) + " should have tabIndex -1, but has tabIndex " + tabIndexGetter.call(elm));
        }
        bindDocumentMousedownMouseupHandlers(elm);
        // Unbind any focus listeners we may have going on
        ignoreFocus(elm);
        // This focusin listener is to catch focusin events from keyboard interactions
        // A better solution would perhaps be to listen for keydown events, but
        // the keydown event happens on whatever element already has focus (or no element
        // at all in the case of the location bar. So, instead we have to assume that focusin
        // without a mousedown means keyboard navigation
        addEventListener.call(elm, 'focusin', skipShadowHandler, true);
    }
    function ignoreFocusIn(elm) {
        removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var nativeGetRootNode = Node.prototype.getRootNode;
    /**
     * Get the root by climbing up the dom tree, beyond the shadow root
     * If Node.prototype.getRootNode is supported, use it
     * else, assume we are working in non-native shadow mode and climb using parentNode
     */
    var getDocumentOrRootNode = !isUndefined(nativeGetRootNode)
        ? nativeGetRootNode
        : function () {
            var node = this;
            var nodeParent;
            while (!isNull((nodeParent = parentNodeGetter.call(node)))) {
                node = nodeParent;
            }
            return node;
        };
    /**
     * Get the shadow root
     * getNodeOwner() returns the host element that owns the given node
     * Note: getNodeOwner() returns null when running in native-shadow mode.
     *  Fallback to using the native getRootNode() to discover the root node.
     *  This is because, it is not possible to inspect the node and decide if it is part
     *  of a native shadow or the synthetic shadow.
     * @param {Node} node
     */
    function getNearestRoot(node) {
        var ownerNode = getNodeOwner(node);
        if (isNull(ownerNode)) {
            // we hit a wall, either we are in native shadow mode or the node is not in lwc boundary.
            return getDocumentOrRootNode.call(node);
        }
        return getShadowRoot(ownerNode);
    }
    function patchedGetRootNode(options) {
        var composed = isUndefined(options) ? false : !!options.composed;
        return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
    }
    function apply$1() {
        defineProperty(Node.prototype, 'getRootNode', {
            value: patchedGetRootNode,
            enumerable: true,
            configurable: true,
            writable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$1();
    }

    // when finding a slot in the DOM, we can fold it if it is contained
    // inside another slot.
    function foldSlotElement(slot) {
        var parent = parentElementGetter.call(slot);
        while (!isNull(parent) && isSlotElement(parent)) {
            slot = parent;
            parent = parentElementGetter.call(slot);
        }
        return slot;
    }
    function isNodeSlotted(host, node) {
        {
            assert.invariant(host instanceof HTMLElement, "isNodeSlotted() should be called with a host as the first argument instead of " + host);
            assert.invariant(node instanceof Node, "isNodeSlotted() should be called with a node as the second argument instead of " + node);
            assert.isTrue(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, "isNodeSlotted() should never be called with a node that is not a child node of " + host);
        }
        var hostKey = getNodeKey(host);
        // this routine assumes that the node is coming from a different shadow (it is not owned by the host)
        // just in case the provided node is not an element
        var currentElement = node instanceof Element ? node : parentElementGetter.call(node);
        while (!isNull(currentElement) && currentElement !== host) {
            var elmOwnerKey = getNodeNearestOwnerKey(currentElement);
            var parent = parentElementGetter.call(currentElement);
            if (elmOwnerKey === hostKey) {
                // we have reached an element inside the host's template, and only if
                // that element is an slot, then the node is considered slotted
                return isSlotElement(currentElement);
            }
            else if (parent === host) {
                return false;
            }
            else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
                // we are crossing a boundary of some sort since the elm and its parent
                // have different owner key. for slotted elements, this is possible
                // if the parent happens to be a slot.
                if (isSlotElement(parent)) {
                    /**
                     * the slot parent might be allocated inside another slot, think of:
                     * <x-root> (<--- root element)
                     *    <x-parent> (<--- own by x-root)
                     *       <x-child> (<--- own by x-root)
                     *           <slot> (<--- own by x-child)
                     *               <slot> (<--- own by x-parent)
                     *                  <div> (<--- own by x-root)
                     *
                     * while checking if x-parent has the div slotted, we need to traverse
                     * up, but when finding the first slot, we skip that one in favor of the
                     * most outer slot parent before jumping into its corresponding host.
                     */
                    currentElement = getNodeOwner(foldSlotElement(parent));
                    if (!isNull(currentElement)) {
                        if (currentElement === host) {
                            // the slot element is a top level element inside the shadow
                            // of a host that was allocated into host in question
                            return true;
                        }
                        else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
                            // the slot element is an element inside the shadow
                            // of a host that was allocated into host in question
                            return true;
                        }
                    }
                }
                else {
                    return false;
                }
            }
            else {
                currentElement = parent;
            }
        }
        return false;
    }
    function getAllSlottedMatches(host, nodeList) {
        var filteredAndPatched = [];
        for (var i = 0, len = nodeList.length; i < len; i += 1) {
            var node = nodeList[i];
            if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
                ArrayPush.call(filteredAndPatched, node);
            }
        }
        return filteredAndPatched;
    }
    function getFirstSlottedMatch(host, nodeList) {
        for (var i = 0, len = nodeList.length; i < len; i += 1) {
            var node = nodeList[i];
            if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
                return node;
            }
        }
        return null;
    }
    function lightDomQuerySelectorAll(elm, selectors) {
        var owner = getNodeOwner(elm);
        if (isNull(owner)) {
            return [];
        }
        var nodeList = querySelectorAll$1.call(elm, selectors);
        if (getNodeKey(elm)) {
            // it is a custom element, and we should then filter by slotted elements
            return getAllSlottedMatches(elm, nodeList);
        }
        else {
            // regular element, we should then filter by ownership
            return getAllMatches(owner, nodeList);
        }
    }
    function lightDomQuerySelector(elm, selector) {
        var owner = getNodeOwner(elm);
        if (isNull(owner)) {
            // the it is a root, and those can't have a lightdom
            return null;
        }
        var nodeList = querySelectorAll$1.call(elm, selector);
        if (getNodeKey(elm)) {
            // it is a custom element, and we should then filter by slotted elements
            return getFirstSlottedMatch(elm, nodeList);
        }
        else {
            // regular element, we should then filter by ownership
            return getFirstMatch(owner, nodeList);
        }
    }
    function PatchedElement(elm) {
        var Ctor = PatchedNode(elm);
        var superAddEventListener = elm.addEventListener, superRemoveEventListener = elm.removeEventListener, superBlur = elm.blur, superFocus = elm.focus;
        // Note: Element.getElementsByTagName and Element.getElementsByClassName are purposefully
        // omitted from the list of patched methods. In order for the querySelector* APIs to run
        // properly in jsdom, we need to make sure those methods doesn't respect the shadow DOM
        // semantic.
        // https://github.com/salesforce/lwc/pull/1179#issuecomment-484041707
        return /** @class */ (function (_super) {
            __extends(PatchedHTMLElement, _super);
            function PatchedHTMLElement() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            // Regular Elements
            PatchedHTMLElement.prototype.querySelector = function (selector) {
                return lightDomQuerySelector(this, selector);
            };
            PatchedHTMLElement.prototype.querySelectorAll = function (selectors) {
                return createStaticNodeList(lightDomQuerySelectorAll(this, selectors));
            };
            Object.defineProperty(PatchedHTMLElement.prototype, "innerHTML", {
                get: function () {
                    var childNodes = getInternalChildNodes(this);
                    var innerHTML = '';
                    for (var i = 0, len = childNodes.length; i < len; i += 1) {
                        innerHTML += getOuterHTML(childNodes[i]);
                    }
                    return innerHTML;
                },
                set: function (value) {
                    innerHTMLSetter.call(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedHTMLElement.prototype, "outerHTML", {
                get: function () {
                    return getOuterHTML(this);
                },
                set: function (value) {
                    outerHTMLSetter.call(this, value);
                },
                enumerable: true,
                configurable: true
            });
            // CE patches
            PatchedHTMLElement.prototype.attachShadow = function (options) {
                return attachShadow(this, options);
            };
            PatchedHTMLElement.prototype.addEventListener = function (type, listener, options) {
                if (hasSyntheticShadow(this)) {
                    addCustomElementEventListener(this, type, listener, options);
                }
                else {
                    superAddEventListener.call(this, type, listener, options);
                }
            };
            PatchedHTMLElement.prototype.removeEventListener = function (type, listener, options) {
                if (hasSyntheticShadow(this)) {
                    removeCustomElementEventListener(this, type, listener, options);
                }
                else {
                    superRemoveEventListener.call(this, type, listener, options);
                }
            };
            Object.defineProperty(PatchedHTMLElement.prototype, "shadowRoot", {
                get: function () {
                    if (hasSyntheticShadow(this)) {
                        var shadow = getShadowRoot(this);
                        if (shadow.mode === 'open') {
                            return shadow;
                        }
                    }
                    return null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedHTMLElement.prototype, "tabIndex", {
                get: function () {
                    if (hasSyntheticShadow(this) &&
                        isDelegatingFocus(this) &&
                        isFalse(hasAttribute.call(this, 'tabindex'))) {
                        // this cover the case where the default tabindex should be 0 because the
                        // custom element is delegating its focus
                        return 0;
                    }
                    // NOTE: Technically this should be `super.tabIndex` however Typescript
                    // has a known bug while transpiling down to ES5
                    // https://github.com/Microsoft/TypeScript/issues/338
                    var descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                    return descriptor.get.call(this);
                },
                set: function (value) {
                    if (hasSyntheticShadow(this)) {
                        // This tabIndex setter might be confusing unless it is understood that HTML
                        // elements have default tabIndex property values. Natively focusable elements have
                        // a default tabIndex value of 0 and all other elements have a default tabIndex
                        // value of -1. For example, the tabIndex property value is -1 for both <x-foo> and
                        // <x-foo tabindex="-1">, but our delegatesFocus polyfill should only kick in for
                        // the latter case when the value of the tabindex attribute is -1.
                        var delegatesFocus = isDelegatingFocus(this);
                        // Record the state of things before invoking component setter.
                        var prevValue = tabIndexGetter.call(this);
                        var prevHasAttr = hasAttribute.call(this, 'tabindex');
                        // NOTE: Technically this should be `super.tabIndex` however Typescript
                        // has a known bug while transpiling down to ES5
                        // https://github.com/Microsoft/TypeScript/issues/338
                        var descriptor_1 = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                        descriptor_1.set.call(this, value);
                        // Record the state of things after invoking component setter.
                        var currValue = tabIndexGetter.call(this);
                        var currHasAttr = hasAttribute.call(this, 'tabindex');
                        var didValueChange = prevValue !== currValue;
                        // If the tabindex attribute is initially rendered, we can assume that this setter has
                        // previously executed and a listener has been added. We must remove that listener if
                        // the tabIndex property value has changed or if the component no longer renders a
                        // tabindex attribute.
                        if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {
                            if (prevValue === -1) {
                                ignoreFocusIn(this);
                            }
                            if (prevValue === 0 && delegatesFocus) {
                                ignoreFocus(this);
                            }
                        }
                        // If a tabindex attribute was not rendered after invoking its setter, it means the
                        // component is taking control. Do nothing.
                        if (isFalse(currHasAttr)) {
                            return;
                        }
                        // If the tabindex attribute is initially rendered, we can assume that this setter has
                        // previously executed and a listener has been added. If the tabindex attribute is still
                        // rendered after invoking the setter AND the tabIndex property value has not changed,
                        // we don't need to do any work.
                        if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {
                            return;
                        }
                        // At this point we know that a tabindex attribute was rendered after invoking the
                        // setter and that either:
                        // 1) This is the first time this setter is being invoked.
                        // 2) This is not the first time this setter is being invoked and the value is changing.
                        // We need to add the appropriate listeners in either case.
                        if (currValue === -1) {
                            // Add the magic to skip the shadow tree
                            handleFocusIn(this);
                        }
                        if (currValue === 0 && delegatesFocus) {
                            // Add the magic to skip the host element
                            handleFocus(this);
                        }
                        return;
                    }
                    // NOTE: Technically this should be `super.tabIndex` however Typescript
                    // has a known bug while transpiling down to ES5
                    // https://github.com/Microsoft/TypeScript/issues/338
                    var descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                    descriptor.set.call(this, value);
                },
                enumerable: true,
                configurable: true
            });
            PatchedHTMLElement.prototype.blur = function () {
                if (hasSyntheticShadow(this) && isDelegatingFocus(this)) {
                    var currentActiveElement = getActiveElement(this);
                    if (!isNull(currentActiveElement)) {
                        // if there is an active element, blur it
                        currentActiveElement.blur();
                        return;
                    }
                }
                // NOTE: Technically this should be `super.blur` however Typescript
                // has a known bug while transpiling down to ES5
                // https://github.com/Microsoft/TypeScript/issues/338
                return superBlur.call(this);
            };
            PatchedHTMLElement.prototype.focus = function () {
                disableKeyboardFocusNavigationRoutines();
                // TODO: #1327 - Shadow DOM semantics for focus method
                superFocus.call(this);
                enableKeyboardFocusNavigationRoutines();
            };
            Object.defineProperty(PatchedHTMLElement.prototype, "childNodes", {
                get: function () {
                    if (hasSyntheticShadow(this)) {
                        var owner = getNodeOwner(this);
                        var childNodes = isNull(owner)
                            ? []
                            : getAllMatches(owner, getFilteredChildNodes(this));
                        if (isFalse(hasNativeSymbolsSupport$1) &&
                            isExternalChildNodeAccessorFlagOn()) {
                            // inserting a comment node as the first childNode to trick the IE11
                            // DevTool to show the content of the shadowRoot, this should only happen
                            // in dev-mode and in IE11 (which we detect by looking at the symbol).
                            // Plus it should only be in place if we know it is an external invoker.
                            ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
                        }
                        return createStaticNodeList(childNodes);
                    }
                    // nothing to do here since this does not have a synthetic shadow attached to it
                    return childNodesGetter.call(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedHTMLElement.prototype, "children", {
                get: function () {
                    if (hasSyntheticShadow(this)) {
                        var owner = getNodeOwner(this);
                        var childNodes = isNull(owner)
                            ? []
                            : getAllMatches(owner, getFilteredChildNodes(this));
                        return createStaticHTMLCollection(ArrayFilter.call(childNodes, function (node) { return node instanceof Element; }));
                    }
                    // nothing to do here since this does not have a synthetic shadow attached to it
                    return childrenGetter.call(this);
                },
                enumerable: true,
                configurable: true
            });
            return PatchedHTMLElement;
        }(Ctor));
    }

    // We can use a single observer without having to worry about leaking because
    // "Registered observers in a nodes registered observer list have a weak
    // reference to the node."
    // https://dom.spec.whatwg.org/#garbage-collection
    var observer;
    var observerConfig = { childList: true };
    var SlotChangeKey = createFieldName('slotchange');
    function initSlotObserver() {
        return new MutationObserver(function (mutations) {
            var slots = [];
            forEach.call(mutations, function (mutation) {
                {
                    assert.isTrue(mutation.type === 'childList', "Invalid mutation type: " + mutation.type + ". This mutation handler for slots should only handle \"childList\" mutations.");
                }
                var slot = mutation.target;
                if (ArrayIndexOf.call(slots, slot) === -1) {
                    ArrayPush.call(slots, slot);
                    dispatchEvent.call(slot, new CustomEvent('slotchange'));
                }
            });
        });
    }
    function getFilteredSlotAssignedNodes(slot) {
        var owner = getNodeOwner(slot);
        if (isNull(owner)) {
            return [];
        }
        var childNodes = collectionSlice(childNodesGetter.call(slot));
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        return ArrayReduce.call(childNodes, function (seed, child) {
            if (!isNodeOwnedBy(owner, child)) {
                ArrayPush.call(seed, child);
            }
            return seed;
        }, []);
    }
    function getFilteredSlotFlattenNodes(slot) {
        var childNodes = collectionSlice(childNodesGetter.call(slot));
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        return ArrayReduce.call(childNodes, function (seed, child) {
            if (child instanceof Element && isSlotElement(child)) {
                ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
            }
            else {
                ArrayPush.call(seed, child);
            }
            return seed;
        }, []);
    }
    function PatchedSlotElement(elm) {
        var Ctor = PatchedElement(elm);
        var superAddEventListener = elm.addEventListener;
        return /** @class */ (function (_super) {
            __extends(PatchedHTMLSlotElement, _super);
            function PatchedHTMLSlotElement() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            PatchedHTMLSlotElement.prototype.addEventListener = function (type, listener, options) {
                if (type === 'slotchange' && !getInternalField(this, SlotChangeKey)) {
                    setInternalField(this, SlotChangeKey, true);
                    if (!observer) {
                        observer = initSlotObserver();
                    }
                    MutationObserverObserve.call(observer, this, observerConfig);
                }
                superAddEventListener.call(this, type, listener, options);
            };
            PatchedHTMLSlotElement.prototype.assignedElements = function (options) {
                var flatten = !isUndefined(options) && isTrue(options.flatten);
                var nodes = flatten
                    ? getFilteredSlotFlattenNodes(this)
                    : getFilteredSlotAssignedNodes(this);
                return ArrayFilter.call(nodes, function (node) { return node instanceof Element; });
            };
            PatchedHTMLSlotElement.prototype.assignedNodes = function (options) {
                var flatten = !isUndefined(options) && isTrue(options.flatten);
                return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
            };
            Object.defineProperty(PatchedHTMLSlotElement.prototype, "name", {
                get: function () {
                    // in browsers that do not support shadow dom, slot's name attribute is not reflective
                    var name = getAttribute.call(this, 'name');
                    return isNull(name) ? '' : name;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedHTMLSlotElement.prototype, "childNodes", {
                get: function () {
                    var owner = getNodeOwner(this);
                    var childNodes = isNull(owner)
                        ? []
                        : getAllMatches(owner, getFilteredChildNodes(this));
                    return createStaticNodeList(childNodes);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedHTMLSlotElement.prototype, "children", {
                get: function () {
                    var owner = getNodeOwner(this);
                    var childNodes = isNull(owner)
                        ? []
                        : getAllMatches(owner, getFilteredChildNodes(this));
                    return createStaticHTMLCollection(ArrayFilter.call(childNodes, function (node) { return node instanceof Element; }));
                },
                enumerable: true,
                configurable: true
            });
            return PatchedHTMLSlotElement;
        }(Ctor));
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Extract the patched getRootNode
    var patchedGetRootNode$1 = Node.prototype.getRootNode;
    function getNodeOwner(node) {
        if (!(node instanceof Node)) {
            return null;
        }
        var ownerKey = getNodeNearestOwnerKey(node);
        if (isUndefined(ownerKey)) {
            return null;
        }
        var nodeOwner = node;
        // At this point, node is a valid node with owner identity, now we need to find the owner node
        // search for a custom element with a VM that owns the first element with owner identity attached to it
        while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
            nodeOwner = parentNodeGetter.call(nodeOwner);
        }
        if (isNull(nodeOwner)) {
            return null;
        }
        return nodeOwner;
    }
    function isSlotElement(elm) {
        return tagNameGetter.call(elm) === 'SLOT';
    }
    function isNodeOwnedBy(owner, node) {
        {
            assert.invariant(owner instanceof HTMLElement, "isNodeOwnedBy() should be called with an element as the first argument instead of " + owner);
            assert.invariant(node instanceof Node, "isNodeOwnedBy() should be called with a node as the second argument instead of " + node);
            assert.isTrue(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, "isNodeOwnedBy() should never be called with a node that is not a child node of " + owner);
        }
        var ownerKey = getNodeNearestOwnerKey(node);
        return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
    }
    function shadowRootChildNodes(root) {
        var elm = getHost(root);
        return getAllMatches(elm, childNodesGetter.call(elm));
    }
    function getAllMatches(owner, nodeList) {
        var filteredAndPatched = [];
        for (var i = 0, len = nodeList.length; i < len; i += 1) {
            var node = nodeList[i];
            var isOwned = isNodeOwnedBy(owner, node);
            if (isOwned) {
                // Patch querySelector, querySelectorAll, etc
                // if element is owned by VM
                ArrayPush.call(filteredAndPatched, node);
            }
        }
        return filteredAndPatched;
    }
    function getFirstMatch(owner, nodeList) {
        for (var i = 0, len = nodeList.length; i < len; i += 1) {
            if (isNodeOwnedBy(owner, nodeList[i])) {
                return nodeList[i];
            }
        }
        return null;
    }
    function shadowRootQuerySelector(root, selector) {
        var elm = getHost(root);
        var nodeList = querySelectorAll$1.call(elm, selector);
        return getFirstMatch(elm, nodeList);
    }
    function shadowRootQuerySelectorAll(root, selector) {
        var elm = getHost(root);
        var nodeList = querySelectorAll$1.call(elm, selector);
        return getAllMatches(elm, nodeList);
    }
    function getFilteredChildNodes(node) {
        var children;
        if (!isUndefined(getNodeKey(node))) {
            // node itself is a custom element
            // lwc element, in which case we need to get only the nodes
            // that were slotted
            var slots = querySelectorAll$1.call(node, 'slot');
            children = ArrayReduce.call(slots, function (seed, slot) {
                if (isNodeOwnedBy(node, slot)) {
                    ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
                }
                return seed;
            }, []);
        }
        else {
            // regular element
            children = childNodesGetter.call(node);
        }
        var owner = getNodeOwner(node);
        if (isNull(owner)) {
            return [];
        }
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        return ArrayReduce.call(children, function (seed, child) {
            if (isNodeOwnedBy(owner, child)) {
                ArrayPush.call(seed, child);
            }
            return seed;
        }, []);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // DO NOT CHANGE this:
    // these two values need to be in sync with engine
    var OwnerKey = '$$OwnerKey$$';
    var OwnKey = '$$OwnKey$$';
    var hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
    function getNodeOwnerKey(node) {
        return node[OwnerKey];
    }
    function setNodeOwnerKey(node, value) {
        {
            // in dev-mode, we are more restrictive about what you can do with the owner key
            defineProperty(node, OwnerKey, {
                value: value,
                configurable: true,
            });
        }
    }
    function setNodeKey(node, value) {
        {
            // in dev-mode, we are more restrictive about what you can do with the own key
            defineProperty(node, OwnKey, {
                value: value,
            });
        }
    }
    function getNodeNearestOwnerKey(node) {
        var ownerNode = node;
        var ownerKey;
        // search for the first element with owner identity (just in case of manually inserted elements)
        while (!isNull(ownerNode)) {
            ownerKey = ownerNode[OwnerKey];
            if (!isUndefined(ownerKey)) {
                return ownerKey;
            }
            ownerNode = parentNodeGetter.call(ownerNode);
        }
    }
    function getNodeKey(node) {
        return node[OwnKey];
    }
    function isNodeShadowed(node) {
        return !isUndefined(getNodeNearestOwnerKey(node));
    }
    function getShadowParent(node, value) {
        var owner = getNodeOwner(node);
        if (value === owner) {
            // walking up via parent chain might end up in the shadow root element
            return getShadowRoot(owner);
        }
        else if (value instanceof Element) {
            if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
                // the element and its parent node belong to the same shadow root
                return value;
            }
            else if (!isNull(owner) && isSlotElement(value)) {
                // slotted elements must be top level childNodes of the slot element
                // where they slotted into, but its shadowed parent is always the
                // owner of the slot.
                var slotOwner = getNodeOwner(value);
                if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
                    // it is a slotted element, and therefore its parent is always going to be the host of the slot
                    return slotOwner;
                }
            }
        }
        return null;
    }
    function PatchedNode(node) {
        var Ctor = getPrototypeOf(node).constructor;
        var PatchedNodeClass = /** @class */ (function () {
            function PatchedNodeClass() {
                // Patched classes are not supposed to be instantiated directly, ever!
                throw new TypeError('Illegal constructor');
            }
            PatchedNodeClass.prototype.hasChildNodes = function () {
                return getInternalChildNodes(this).length > 0;
            };
            Object.defineProperty(PatchedNodeClass.prototype, "firstChild", {
                get: function () {
                    var childNodes = getInternalChildNodes(this);
                    return childNodes[0] || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "lastChild", {
                get: function () {
                    var childNodes = getInternalChildNodes(this);
                    return childNodes[childNodes.length - 1] || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "textContent", {
                get: function () {
                    return getTextContent(this);
                },
                set: function (value) {
                    textContextSetter.call(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "childElementCount", {
                get: function () {
                    return this.children.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "firstElementChild", {
                get: function () {
                    return this.children[0] || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "lastElementChild", {
                get: function () {
                    var children = this.children;
                    return children.item(children.length - 1) || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "assignedSlot", {
                get: function () {
                    var parentNode = parentNodeGetter.call(this);
                    /**
                     * if it doesn't have a parent node,
                     * or the parent is not an slot element
                     * or they both belong to the same template (default content)
                     * we should assume that it is not slotted
                     */
                    if (isNull(parentNode) ||
                        !isSlotElement(parentNode) ||
                        getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
                        return null;
                    }
                    return parentNode;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "parentNode", {
                get: function () {
                    var value = parentNodeGetter.call(this);
                    if (isNull(value)) {
                        return value;
                    }
                    return getShadowParent(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PatchedNodeClass.prototype, "parentElement", {
                get: function () {
                    var value = parentNodeGetter.call(this);
                    if (isNull(value)) {
                        return null;
                    }
                    var parentNode = getShadowParent(this, value);
                    // it could be that the parentNode is the shadowRoot, in which case
                    // we need to return null.
                    return parentNode instanceof Element ? parentNode : null;
                },
                enumerable: true,
                configurable: true
            });
            PatchedNodeClass.prototype.compareDocumentPosition = function (otherNode) {
                if (patchedGetRootNode$1.call(this) === otherNode) {
                    // "this" is in a shadow tree where the shadow root is the "otherNode".
                    return 10; // Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING
                }
                else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                    // "this" and "otherNode" belongs to 2 different shadow tree.
                    return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING
                }
                // Since "this" and "otherNode" are part of the same shadow tree we can safely rely to the native
                // Node.compareDocumentPosition implementation.
                return compareDocumentPosition.call(this, otherNode);
            };
            PatchedNodeClass.prototype.contains = function (otherNode) {
                if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                    // it is from another shadow
                    return false;
                }
                return ((compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                    0);
            };
            PatchedNodeClass.prototype.cloneNode = function (deep) {
                var clone = cloneNode.call(this, false);
                // Per spec, browsers only care about truthy values
                // Not strict true or false
                if (!deep) {
                    return clone;
                }
                var childNodes = getInternalChildNodes(this);
                for (var i = 0, len = childNodes.length; i < len; i += 1) {
                    clone.appendChild(childNodes[i].cloneNode(true));
                }
                return clone;
            };
            return PatchedNodeClass;
        }());
        // prototype inheritance dance
        setPrototypeOf(PatchedNodeClass, Ctor);
        setPrototypeOf(PatchedNodeClass.prototype, Ctor.prototype);
        return PatchedNodeClass;
    }
    var internalChildNodeAccessorFlag = false;
    /**
     * These 2 methods are providing a machinery to understand who is accessing the
     * .childNodes member property of a node. If it is used from inside the synthetic shadow
     * or from an external invoker. This helps to produce the right output in one very peculiar
     * case, the IE11 debugging comment for shadowRoot representation on the devtool.
     */
    function isExternalChildNodeAccessorFlagOn() {
        return !internalChildNodeAccessorFlag;
    }
    var getInternalChildNodes = isFalse(hasNativeSymbolsSupport$1)
        ? function (node) {
            internalChildNodeAccessorFlag = true;
            var childNodes;
            var error = null;
            try {
                childNodes = node.childNodes;
            }
            catch (e) {
                // childNodes accessor should never throw, but just in case!
                error = e;
            }
            finally {
                internalChildNodeAccessorFlag = false;
                if (!isNull(error)) {
                    // re-throwing after restoring the state machinery for setInternalChildNodeAccessorFlag
                    throw error; // eslint-disable-line no-unsafe-finally
                }
            }
            return childNodes;
        }
        : function (node) {
            return node.childNodes;
        };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var skipGlobalPatching;
    function isGlobalPatchingSkipped(node) {
        if (isUndefined(skipGlobalPatching)) {
            var ownerDocument = getOwnerDocument(node);
            skipGlobalPatching =
                ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
        }
        return isTrue(skipGlobalPatching);
    }
    function apply$2() {
        function elemFromPoint(left, top) {
            var element = elementFromPoint.call(this, left, top);
            if (isNull(element)) {
                return element;
            }
            return retarget(this, pathComposer(element, true));
        }
        // https://github.com/Microsoft/TypeScript/issues/14139
        Document.prototype.elementFromPoint = elemFromPoint;
        // Go until we reach to top of the LWC tree
        defineProperty(Document.prototype, 'activeElement', {
            get: function () {
                var node = DocumentPrototypeActiveElement.call(this);
                if (isNull(node)) {
                    return node;
                }
                while (!isUndefined(getNodeOwnerKey(node))) {
                    node = parentElementGetter.call(node);
                    if (isNull(node)) {
                        return null;
                    }
                }
                if (node.tagName === 'HTML') {
                    // IE 11. Active element should never be html element
                    node = this.body;
                }
                return node;
            },
            enumerable: true,
            configurable: true,
        });
        // The following patched methods hide shadowed elements from global
        // traversing mechanisms. They are simplified for performance reasons to
        // filter by ownership and do not account for slotted elements. This
        // compromise is fine for our synthetic shadow dom because root elements
        // cannot have slotted elements.
        // Another compromise here is that all these traversing methods will return
        // static HTMLCollection or static NodeList. We decided that this compromise
        // is not a big problem considering the amount of code that is relying on
        // the liveliness of these results are rare.
        defineProperty(Document.prototype, 'getElementById', {
            value: function () {
                var elm = getElementById.apply(this, ArraySlice.call(arguments));
                if (isNull(elm)) {
                    return null;
                }
                return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'querySelector', {
            value: function () {
                var elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
                var filtered = collectionFind(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
                return !isUndefined(filtered) ? filtered : null;
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'querySelectorAll', {
            value: function () {
                var elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
                var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
                return createStaticNodeList(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'getElementsByClassName', {
            value: function () {
                var elements = getElementsByClassName.apply(this, ArraySlice.call(arguments));
                var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'getElementsByTagName', {
            value: function () {
                var elements = getElementsByTagName.apply(this, ArraySlice.call(arguments));
                var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(Document.prototype, 'getElementsByTagNameNS', {
            value: function () {
                var elements = getElementsByTagNameNS.apply(this, ArraySlice.call(arguments));
                var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(
        // In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype
        getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName')
            ? HTMLDocument.prototype
            : Document.prototype, 'getElementsByName', {
            value: function () {
                var elements = getElementsByName.apply(this, ArraySlice.call(arguments));
                var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
                return createStaticNodeList(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$2();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var skipGlobalPatching$1;
    function isGlobalPatchingSkipped$1(node) {
        if (isUndefined(skipGlobalPatching$1)) {
            var ownerDocument = getOwnerDocument(node);
            skipGlobalPatching$1 =
                ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
        }
        return isTrue(skipGlobalPatching$1);
    }
    function apply$3() {
        var HTMLBodyElementPrototype = HTMLBodyElement.prototype;
        // The following patched methods hide shadowed elements from global
        // traversing mechanisms. They are simplified for performance reasons to
        // filter by ownership and do not account for slotted elements. This
        // compromise is fine for our synthetic shadow dom because root elements
        // cannot have slotted elements.
        // Another compromise here is that all these traversing methods will return
        // static HTMLCollection or static NodeList. We decided that this compromise
        // is not a big problem considering the amount of code that is relying on
        // the liveliness of these results are rare.
        defineProperty(HTMLBodyElementPrototype, 'querySelector', {
            value: function () {
                var elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
                var ownerKey = getNodeOwnerKey(this);
                // Return the first non shadow element
                var filtered = collectionFind(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
                return !isUndefined(filtered) ? filtered : null;
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'querySelectorAll', {
            value: function () {
                var elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
                var ownerKey = getNodeOwnerKey(this);
                var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
                return createStaticNodeList(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'getElementsByClassName', {
            value: function () {
                var elements = getElementsByClassName$1.apply(this, ArraySlice.call(arguments));
                var ownerKey = getNodeOwnerKey(this);
                var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'getElementsByTagName', {
            value: function () {
                var elements = getElementsByTagName$1.apply(this, ArraySlice.call(arguments));
                var ownerKey = getNodeOwnerKey(this);
                var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
        defineProperty(HTMLBodyElementPrototype, 'getElementsByTagNameNS', {
            value: function () {
                var elements = getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments));
                var ownerKey = getNodeOwnerKey(this);
                var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
                return createStaticHTMLCollection(filtered);
            },
            writable: true,
            enumerable: true,
            configurable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$3();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$4() {
        Object.defineProperty(window, 'ShadowRoot', {
            value: SyntheticShadowRoot,
            configurable: true,
            writable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$4();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
    function detect() {
        if (!composedDescriptor) {
            // No need to apply this polyfill if this client completely lacks
            // support for the composed property.
            return false;
        }
        // Assigning a throwaway click event here to suppress a ts error when we
        // pass clickEvent into the composed getter below. The error is:
        // [ts] Variable 'clickEvent' is used before being assigned.
        var clickEvent = new Event('click');
        var button = document.createElement('button');
        button.addEventListener('click', function (event) { return (clickEvent = event); });
        button.click();
        return !composedDescriptor.get.call(clickEvent);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');
    function handleClick(event) {
        Object.defineProperty(event, 'composed', {
            configurable: true,
            enumerable: true,
            get: function () {
                return true;
            },
        });
    }
    function apply$5() {
        HTMLElement.prototype.click = function () {
            addEventListener.call(this, 'click', handleClick);
            try {
                originalClickDescriptor.value.call(this);
            }
            finally {
                removeEventListener.call(this, 'click', handleClick);
            }
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect()) {
        apply$5();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$1() {
        return Object.getOwnPropertyDescriptor(Event.prototype, 'composed') === undefined;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$6() {
        // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937
        var composedEvents = assign(create(null), {
            blur: 1,
            focus: 1,
            focusin: 1,
            focusout: 1,
            click: 1,
            dblclick: 1,
            mousedown: 1,
            mouseenter: 1,
            mouseleave: 1,
            mousemove: 1,
            mouseout: 1,
            mouseover: 1,
            mouseup: 1,
            wheel: 1,
            beforeinput: 1,
            input: 1,
            keydown: 1,
            keyup: 1,
            compositionstart: 1,
            compositionupdate: 1,
            compositionend: 1,
            touchstart: 1,
            touchend: 1,
            touchmove: 1,
            touchcancel: 1,
            pointerover: 1,
            pointerenter: 1,
            pointerdown: 1,
            pointermove: 1,
            pointerup: 1,
            pointercancel: 1,
            pointerout: 1,
            pointerleave: 1,
            gotpointercapture: 1,
            lostpointercapture: 1,
            dragstart: 1,
            drag: 1,
            dragenter: 1,
            dragleave: 1,
            dragover: 1,
            drop: 1,
            dragend: 1,
            DOMActivate: 1,
            DOMFocusIn: 1,
            DOMFocusOut: 1,
            keypress: 1,
        });
        // Composed for Native events
        Object.defineProperties(Event.prototype, {
            composed: {
                get: function () {
                    var type = this.type;
                    return composedEvents[type] === 1;
                },
                configurable: true,
                enumerable: true,
            },
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect$1()) {
        apply$6();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var OriginalCustomEvent = window.CustomEvent;
    function PatchedCustomEvent(type, eventInitDict) {
        var event = new OriginalCustomEvent(type, eventInitDict);
        // support for composed on custom events
        Object.defineProperties(event, {
            composed: {
                // We can't use "value" here, because IE11 doesn't like mixing and matching
                // value with get() from Event.prototype.
                get: function () {
                    return !!(eventInitDict && eventInitDict.composed);
                },
                configurable: true,
                enumerable: true,
            },
        });
        return event;
    }
    function apply$7() {
        window.CustomEvent = PatchedCustomEvent;
        window.CustomEvent.prototype = OriginalCustomEvent.prototype;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$7();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$8 () {
        var originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed')
            .get;
        Object.defineProperties(FocusEvent.prototype, {
            composed: {
                get: function () {
                    var isTrusted = this.isTrusted;
                    var composed = originalComposedGetter.call(this);
                    if (isTrusted && composed === false) {
                        return true;
                    }
                    return composed;
                },
                enumerable: true,
                configurable: true,
            },
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$8();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$2() {
        // Note: when using this in mobile apps, we might have a DOM that does not support iframes.
        return typeof HTMLIFrameElement !== 'undefined';
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function apply$9() {
        // the iframe property descriptor for `contentWindow` should always be available, otherwise this method should never be called
        var desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
        var originalGetter = desc.get;
        desc.get = function () {
            var original = originalGetter.call(this);
            // If the original iframe element is not a keyed node, then do not wrap it
            if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
                return original;
            }
            // only if the element is an iframe inside a shadowRoot, we care about this problem
            // because in that case, the code that is accessing the iframe, is very likely code
            // compiled with proxy-compat transformation. It is true that other code without those
            // transformations might also access an iframe from within a shadowRoot, but in that,
            // case, which is more rare, we still return the wrapper, and it should work the same,
            // this part is just an optimization.
            return wrapIframeWindow(original);
        };
        defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
    }
    function wrapIframeWindow(win) {
        return {
            addEventListener: function () {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.addEventListener.apply(win, arguments);
            },
            blur: function () {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.blur.apply(win, arguments);
            },
            close: function () {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.close.apply(win, arguments);
            },
            focus: function () {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.focus.apply(win, arguments);
            },
            postMessage: function () {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.postMessage.apply(win, arguments);
            },
            removeEventListener: function () {
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return win.removeEventListener.apply(win, arguments);
            },
            get closed() {
                return win.closed;
            },
            get frames() {
                return win.frames;
            },
            get length() {
                return win.length;
            },
            get location() {
                return win.location;
            },
            set location(value) {
                win.location = value;
            },
            get opener() {
                return win.opener;
            },
            get parent() {
                return win.parent;
            },
            get self() {
                return win.self;
            },
            get top() {
                return win.top;
            },
            get window() {
                return win.window;
            },
        }; // this is limited
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect$2()) {
        apply$9();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var OriginalMutationObserver = window.MutationObserver;
    var _a$8 = OriginalMutationObserver.prototype, originalDisconnect = _a$8.disconnect, originalObserve = _a$8.observe, originalTakeRecords = _a$8.takeRecords;
    // Internal fields to maintain relationships
    var wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
    var observerLookupField = '$$lwcNodeObservers$$';
    var observerToNodesMap = new WeakMap();
    /**
     * Retarget the mutation record's target value to its shadowRoot
     * @param {MutationRecord} originalRecord
     */
    function retargetMutationRecord(originalRecord) {
        var addedNodes = originalRecord.addedNodes, removedNodes = originalRecord.removedNodes, target = originalRecord.target, type = originalRecord.type;
        var retargetedRecord = create(MutationRecord.prototype);
        defineProperties(retargetedRecord, {
            addedNodes: {
                get: function () {
                    return addedNodes;
                },
                enumerable: true,
                configurable: true,
            },
            removedNodes: {
                get: function () {
                    return removedNodes;
                },
                enumerable: true,
                configurable: true,
            },
            type: {
                get: function () {
                    return type;
                },
                enumerable: true,
                configurable: true,
            },
            target: {
                get: function () {
                    return target.shadowRoot;
                },
                enumerable: true,
                configurable: true,
            },
        });
        return retargetedRecord;
    }
    /**
     * Utility to identify if a target node is being observed by the given observer
     * Start at the current node, if the observer is registered to observe the current node, the mutation qualifies
     * @param {MutationObserver} observer
     * @param {Node} target
     */
    function isQualifiedObserver(observer, target) {
        var parentNode = target;
        while (!isNull(parentNode)) {
            var parentNodeObservers = parentNode[observerLookupField];
            if (!isUndefined(parentNodeObservers) &&
                (parentNodeObservers[0] === observer || // perf optimization to check for the first item is a match
                    ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
                return true;
            }
            parentNode = parentNode.parentNode;
        }
        return false;
    }
    /**
     * This function provides a shadow dom compliant filtered view of mutation records for a given observer.
     *
     * The key logic here is to determine if a given observer has been registered to observe any nodes
     * between the target node of a mutation record to the target's root node.
     * This function also retargets records when mutations occur directly under the shadow root
     * @param {MutationRecords[]} mutations
     * @param {MutationObserver} observer
     */
    function filterMutationRecords(mutations, observer) {
        return ArrayReduce.call(mutations, function (filteredSet, record) {
            var target = record.target, addedNodes = record.addedNodes, removedNodes = record.removedNodes, type = record.type;
            // If target is an lwc host,
            // Determine if the mutations affected the host or the shadowRoot
            // Mutations affecting host: changes to slot content
            // Mutations affecting shadowRoot: changes to template content
            if (type === 'childList' && !isUndefined(getNodeKey(target))) {
                // In case of added nodes, we can climb up the tree and determine eligibility
                if (addedNodes.length > 0) {
                    // Optimization: Peek in and test one node to decide if the MutationRecord qualifies
                    // The remaining nodes in this MutationRecord will have the same ownerKey
                    var sampleNode = addedNodes[0];
                    if (isQualifiedObserver(observer, sampleNode)) {
                        // If the target was being observed, then return record as-is
                        // this will be the case for slot content
                        if (target[observerLookupField] &&
                            (target[observerLookupField][0] === observer ||
                                ArrayIndexOf.call(target[observerLookupField], observer) !== -1)) {
                            ArrayPush.call(filteredSet, record);
                        }
                        else {
                            // else, must be observing the shadowRoot
                            ArrayPush.call(filteredSet, retargetMutationRecord(record));
                        }
                    }
                }
                else {
                    // In the case of removed nodes, climbing the tree is not an option as the nodes are disconnected
                    // We can only check if either the host or shadow root was observed and qualify the record
                    var shadowRoot = target.shadowRoot;
                    var sampleNode = removedNodes[0];
                    if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && // trickery: sampleNode is slot content
                        isQualifiedObserver(observer, target) // use target as a close enough reference to climb up
                    ) {
                        ArrayPush.call(filteredSet, record);
                    }
                    else if (shadowRoot &&
                        shadowRoot[observerLookupField] &&
                        (shadowRoot[observerLookupField][0] === observer ||
                            ArrayIndexOf.call(shadowRoot[observerLookupField], observer) !== -1)) {
                        ArrayPush.call(filteredSet, retargetMutationRecord(record));
                    }
                }
            }
            else {
                // Mutation happened under a root node(shadow root or document) and the decision is straighforward
                // Ascend the tree starting from target and check if observer is qualified
                if (isQualifiedObserver(observer, target)) {
                    ArrayPush.call(filteredSet, record);
                }
            }
            return filteredSet;
        }, []);
    }
    function getWrappedCallback(callback) {
        var wrappedCallback = callback[wrapperLookupField];
        if (isUndefined(wrappedCallback)) {
            wrappedCallback = callback[wrapperLookupField] = function (mutations, observer) {
                // Filter mutation records
                var filteredRecords = filterMutationRecords(mutations, observer);
                // If not records are eligible for the observer, do not invoke callback
                if (filteredRecords.length === 0) {
                    return;
                }
                callback.call(observer, filteredRecords, observer);
            };
        }
        return wrappedCallback;
    }
    /**
     * Patched MutationObserver constructor.
     * 1. Wrap the callback to filter out MutationRecords based on dom ownership
     * 2. Add a property field to track all observed targets of the observer instance
     * @param {MutationCallback} callback
     */
    function PatchedMutationObserver(callback) {
        var wrappedCallback = getWrappedCallback(callback);
        var observer = new OriginalMutationObserver(wrappedCallback);
        return observer;
    }
    function patchedDisconnect() {
        var _this = this;
        originalDisconnect.call(this);
        // Clear the node to observer reference which is a strong references
        var observedNodes = observerToNodesMap.get(this);
        if (!isUndefined(observedNodes)) {
            forEach.call(observedNodes, function (observedNode) {
                var observers = observedNode[observerLookupField];
                if (!isUndefined(observers)) {
                    var index = ArrayIndexOf.call(observers, _this);
                    if (index !== -1) {
                        ArraySplice.call(observers, index, 1);
                    }
                }
            });
            observedNodes.length = 0;
        }
    }
    /**
     * A single mutation observer can observe multiple nodes(target).
     * Maintain a list of all targets that the observer chooses to observe
     * @param {Node} target
     * @param {Object} options
     */
    function patchedObserve(target, options) {
        // Maintain a list of all observers that want to observe a node
        if (isUndefined(target[observerLookupField])) {
            defineProperty(target, observerLookupField, { value: [] });
        }
        // Same observer trying to observe the same node
        if (ArrayIndexOf.call(target[observerLookupField], this) === -1) {
            ArrayPush.call(target[observerLookupField], this);
        } // else There is more bookkeeping to do here https://dom.spec.whatwg.org/#dom-mutationobserver-observe Step #7
        // If the target is a SyntheticShadowRoot, observe the host since the shadowRoot is an empty documentFragment
        if (target instanceof SyntheticShadowRoot) {
            target = target.host;
        }
        // maintain a list of all nodes observed by this observer
        if (observerToNodesMap.has(this)) {
            var observedNodes = observerToNodesMap.get(this);
            if (ArrayIndexOf.call(observedNodes, target) === -1) {
                ArrayPush.call(observedNodes, target);
            }
        }
        else {
            observerToNodesMap.set(this, [target]);
        }
        return originalObserve.call(this, target, options);
    }
    /**
     * Patch the takeRecords() api to filter MutationRecords based on the observed targets
     */
    function patchedTakeRecords() {
        return filterMutationRecords(originalTakeRecords.call(this), this);
    }
    PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
    PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
    PatchedMutationObserver.prototype.observe = patchedObserve;
    PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
    function apply$a() {
        defineProperty(window, 'MutationObserver', {
            value: PatchedMutationObserver,
            configurable: true,
            writable: true,
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    {
        apply$a();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ShadowTokenPrivateKey = '$$ShadowTokenKey$$';
    function getShadowToken(node) {
        return node.$shadowToken$;
    }
    function setShadowToken(node, shadowToken) {
        node.$shadowToken$ = shadowToken;
    }
    /**
     * Patching Element.prototype.$shadowToken$ to mark elements a portal:
     *
     *  - we use a property to allow engines to set a custom attribute that should be
     *    placed into the element to sandbox the css rules defined for the template.
     *
     *  - this custom attribute must be unique.
     *
     **/
    defineProperty(Element.prototype, '$shadowToken$', {
        set: function (shadowToken) {
            var oldShadowToken = this[ShadowTokenPrivateKey];
            if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
                removeAttribute.call(this, oldShadowToken);
            }
            if (!isUndefined(shadowToken)) {
                setAttribute.call(this, shadowToken, '');
            }
            this[ShadowTokenPrivateKey] = shadowToken;
        },
        get: function () {
            return this[ShadowTokenPrivateKey];
        },
        configurable: true,
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var MutationObserver$1 = window.MutationObserver;
    var MutationObserverObserve$1 = MutationObserver$1.prototype.observe;
    var DomManualPrivateKey = '$$DomManualKey$$';
    // We can use a single observer without having to worry about leaking because
    // "Registered observers in a nodes registered observer list have a weak
    // reference to the node."
    // https://dom.spec.whatwg.org/#garbage-collection
    var portalObserver;
    var portalObserverConfig = {
        childList: true,
        subtree: true,
    };
    function adoptChildNode(node, fn, shadowToken) {
        if (getShadowRootResolver(node) === fn) {
            return; // nothing to do here, it is already correctly patched
        }
        setShadowRootResolver(node, fn);
        if (node instanceof Element) {
            setShadowToken(node, shadowToken);
            // recursively patching all children as well
            var childNodes = getInternalChildNodes(node);
            for (var i = 0, len = childNodes.length; i < len; i += 1) {
                var child = childNodes[i];
                adoptChildNode(child, fn, shadowToken);
            }
        }
    }
    function initPortalObserver() {
        return new MutationObserver$1(function (mutations) {
            forEach.call(mutations, function (mutation) {
                var elm = mutation.target, addedNodes = mutation.addedNodes;
                // the target of the mutation should always have a ShadowRootResolver attached to it
                var fn = getShadowRootResolver(elm);
                var shadowToken = getShadowToken(elm);
                for (var i = 0, len = addedNodes.length; i < len; i += 1) {
                    var node = addedNodes[i];
                    adoptChildNode(node, fn, shadowToken);
                }
            });
        });
    }
    function markElementAsPortal(elm) {
        if (isUndefined(portalObserver)) {
            portalObserver = initPortalObserver();
        }
        if (isUndefined(getShadowRootResolver(elm))) {
            // only an element from a within a shadowRoot should be used here
            throw new Error("Invalid Element");
        }
        // install mutation observer for portals
        MutationObserverObserve$1.call(portalObserver, elm, portalObserverConfig);
        // TODO: #1253 - optimization to synchronously adopt new child nodes added
        // to this elm, we can do that by patching the most common operations
        // on the node itself
    }
    /**
     * Patching Element.prototype.$domManual$ to mark elements as portal:
     *
     *  - we use a property to allow engines to signal that a particular element in
     *    a shadow supports manual insertion of child nodes.
     *
     *  - this signal comes as a boolean value, and we use it to install the MO instance
     *    onto the element, to propagate the $ownerKey$ and $shadowToken$ to all new
     *    child nodes.
     *
     *  - at the moment, there is no way to undo this operation, once the element is
     *    marked as $domManual$, setting it to false does nothing.
     *
     **/
    // TODO: #1306 - rename this to $observerConnection$
    defineProperty(Element.prototype, '$domManual$', {
        set: function (v) {
            this[DomManualPrivateKey] = v;
            if (isTrue(v)) {
                markElementAsPortal(this);
            }
        },
        get: function () {
            return this[DomManualPrivateKey];
        },
        configurable: true,
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    Element.prototype.$lwcPolyfill$ = {
        PatchedNode: PatchedNode,
        PatchedElement: PatchedElement,
        PatchedSlotElement: PatchedSlotElement,
    };

}));
/** version: 1.0.2-222.23 */
