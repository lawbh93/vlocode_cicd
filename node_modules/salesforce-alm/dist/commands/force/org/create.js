"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
// This is the legacy converted command file. Ignoring code-coverage since this is generated.
// THIS SHOULD BE REMOVED WHEN CONVERTED TO EXTEND SfdxCommand
/* istanbul ignore file */
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const consts = require("../../../lib/core/constants");
const _ = require("lodash");
const envTypes = require("../../../lib/org/envTypes");
const core_1 = require("@salesforce/core");
const sandboxOrg_1 = require("../../../lib/org/sandbox/sandboxOrg");
const sandboxOrgApi_1 = require("../../../lib/org/sandbox/sandboxOrgApi");
const ToolbeltCommand_1 = require("../../../ToolbeltCommand");
const sandboxProgressReporter_1 = require("../../../lib/org/sandbox/sandboxProgressReporter");
const SFDXCommonMessages = require("../../../lib/messages");
const orgTypes_1 = require("../../../lib/orgTypes");
const sandboxConstants_1 = require("../../../lib/org/sandbox/sandboxConstants");
const Alias = require("../../../lib/core/alias");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'org_create');
const sfdxCommonMessages = SFDXCommonMessages();
class OrgCreateCommand extends ToolbeltCommand_1.ToolbeltCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['postorgcreate'];
    }
    async resolveHubOrgContext() {
        //I'd prefer not to do this, But supporting targetusername natively causes a bunch of problems for the existing dev hub
        //implementation.  Specifically, the default org will override the default dev hub org.  This could fundamentally change the
        //behavior if the scratch org create command was executed with no username args where both a default org and dev hub are setup
        //so for the dev hub case, we first need to make sure that the dev Hub has been determined and then we need to make sure that
        //we'll still default to it.
        if (_.isNil(this.hubOrg)) {
            const devHubUsername = this.flags.targetdevhubusername || this.configAggregator.getPropertyValue('defaultdevhubusername');
            if (!devHubUsername) {
                // if no devhub username passed with flag or config
                throw core_1.SfdxError.create('salesforce-alm', 'org', 'RequiresDevhubUsernameError');
            }
            // if no devhub auth file exists, throw devhub not authorized error
            try {
                await core_1.Org.create({ aliasOrUsername: devHubUsername });
            }
            catch (_a) {
                throw core_1.SfdxError.create('salesforce-alm', 'org', 'DevhubNotAuthorized');
            }
        }
        else if (!_.isNil(this.org)) {
            //unset the default org for the dev hub scenario
            this.org = undefined;
        }
        return await this.resolveLegacyContext();
    }
    async readJsonDefFile() {
        // the -f option
        if (this.flags.definitionfile) {
            this.logger.debug('Reading JSON DefFile %s ', this.flags.definitionfile);
            return core_1.fs.readJson(this.flags.definitionfile);
        }
        else
            return;
    }
    async run() {
        const heroku = require('heroku-cli-util');
        const ScratchOrgCreateCommand = require('../../../lib/org/scratchOrgCreateCommand');
        const createCommand = new ScratchOrgCreateCommand();
        this.logger.debug('Create started with args %s ', this.flags);
        if (this.flags.type === orgTypes_1.OrgTypes.Sandbox) {
            // the -f definitionFile option, both sandbox and scratch org use the flag but scratch org
            // will process it separately in the legacy command invocation
            let sandboxDefFileContents = await this.readJsonDefFile();
            //
            //=====================specific to Sandbox org creation ===========
            //
            if (_.isNil(this.org)) {
                throw core_1.SfdxError.create('salesforce-alm', 'org', 'RequiresUsernameError');
            }
            const sandboxOrg = await sandboxOrg_1.SandboxOrg.getInstance(this.org, this.flags.wait, this.logger, this.flags.clientid);
            if (this.flags.clientid) {
                this.ux.warn(messages.getMessage('commandClientIdNotSupported', [this.flags.clientid]));
            }
            // Keep all console output in the command
            sandboxOrg.on(sandboxConstants_1.SandboxEventNames.EVENT_ASYNCRESULT, results => {
                this.ux.log(messages.getMessage('commandSandboxSuccess', [
                    results.sandboxProcessObj.Id,
                    results.sandboxProcessObj.SandboxName
                ]));
            });
            sandboxOrg.on(sandboxConstants_1.SandboxEventNames.EVENT_STATUS, results => {
                sandboxProgressReporter_1.SandboxProgressReporter.logSandboxProgress(this.ux, results.sandboxProcessObj, results.interval, results.retries, results.waitingOnAuth);
            });
            sandboxOrg.on(sandboxConstants_1.SandboxEventNames.EVENT_RESULT, results => {
                sandboxProgressReporter_1.SandboxProgressReporter.logSandboxProcessResult(this.ux, results.sandboxProcessObj, results.sandboxRes);
                if (results.sandboxRes && results.sandboxRes.authUserName) {
                    if (this.flags.setalias) {
                        Alias.set(this.flags.setalias, results.sandboxRes.authUserName).then(result => this.logger.debug('Set Alias: %s result: %s', this.flags.setalias, result));
                    }
                    if (this.flags.setdefaultusername) {
                        let globalConfig = this.configAggregator.getGlobalConfig();
                        globalConfig.set(core_1.Config.DEFAULT_USERNAME, results.sandboxRes.authUserName);
                        globalConfig
                            .write()
                            .then(result => this.logger.debug('Set defaultUsername: %s result: %s', this.flags.setdefaultusername, result));
                    }
                }
            });
            this.logger.debug('Create Varargs: %s ', this.varargs);
            let sandboxReq = new sandboxOrgApi_1.SandboxRequest();
            // definitionjson and varargs override file input
            Object.assign(sandboxReq, sandboxDefFileContents, this.varargs);
            this.logger.debug('Calling create with SandboxRequest: %s ', sandboxReq);
            return await sandboxOrg.createSandbox(sandboxReq);
        }
        else {
            //
            //=====================specific to Scratch org creation ===========
            //
            const context = await this.resolveHubOrgContext();
            if (!context.flags.clientid) {
                return this.execLegacyCommand(createCommand, context);
            }
            else {
                // If the user supplied a specific client ID, we have no way of knowing if it's
                // a certificate-based Connected App or not. Therefore, we have to assume that
                // we'll need the client secret, so prompt the user for it.
                return heroku
                    .prompt(sfdxCommonMessages.getMessage('stdin', [], 'auth_weblogin'), {
                    mask: true
                })
                    .then(secret => {
                    const map = new Map();
                    map.set('secret', secret);
                    return this.execLegacyCommand(createCommand, context, map);
                });
            }
        }
    }
}
exports.OrgCreateCommand = OrgCreateCommand;
OrgCreateCommand.theDescription = messages.getMessage('commandDescription');
OrgCreateCommand.longDescription = messages.getMessage('commandLongDescription');
OrgCreateCommand.help = messages.getMessage('commandHelp');
OrgCreateCommand.showProgress = true;
OrgCreateCommand.requiresProject = false;
OrgCreateCommand.supportsDevhubUsername = true;
OrgCreateCommand.supportsUsername = true;
OrgCreateCommand.varargs = true;
OrgCreateCommand.orgType = consts.DEFAULT_DEV_HUB_USERNAME;
OrgCreateCommand.flagsConfig = {
    type: command_1.flags.enum({
        char: 't',
        description: messages.getMessage('typeFlagDescription'),
        longDescription: messages.getMessage('typeFlagLongDescription'),
        required: false,
        options: orgTypes_1.creatableOrgTypes(),
        default: orgTypes_1.OrgTypes.Scratch
    }),
    definitionfile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('definitionfileFlagDescription'),
        longDescription: messages.getMessage('definitionfileFlagLongDescription'),
        required: false
    }),
    definitionjson: command_1.flags.string({
        char: 'j',
        description: messages.getMessage('definitionjsonFlagDescription'),
        longDescription: messages.getMessage('definitionjsonFlagLongDescription'),
        hidden: true,
        required: false
    }),
    nonamespace: command_1.flags.boolean({
        char: 'n',
        description: messages.getMessage('nonamespaceFlagDescription'),
        longDescription: messages.getMessage('nonamespaceFlagLongDescription'),
        required: false
    }),
    noancestors: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('noancestorsFlagDescription'),
        longDescription: messages.getMessage('noancestorsFlagLongDescription'),
        required: false
    }),
    clientid: command_1.flags.string({
        char: 'i',
        description: messages.getMessage('clientidFlagDescription'),
        longDescription: messages.getMessage('clientidFlagLongDescription'),
        required: false
    }),
    setdefaultusername: command_1.flags.boolean({
        char: 's',
        description: messages.getMessage('setdefaultusernameFlagDescription'),
        longDescription: messages.getMessage('setdefaultusernameFlagLongDescription'),
        required: false
    }),
    setalias: command_1.flags.string({
        char: 'a',
        description: messages.getMessage('setaliasFlagDescription'),
        longDescription: messages.getMessage('setaliasFlagLongDescription'),
        required: false
    }),
    env: command_1.flags.enum({
        char: 'e',
        description: messages.getMessage('envFlagDescription', [envTypes.creatableTypes().toString()]),
        longDescription: messages.getMessage('envFlagLongDescription', [envTypes.creatableTypes().toString()]),
        required: false,
        hidden: true,
        options: envTypes.creatableTypes()
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: sfdxCommonMessages.getMessage('streamingWait', []),
        longDescription: sfdxCommonMessages.getMessage('streamingWaitLong', []),
        required: false,
        min: kit_1.Duration.minutes(consts.MIN_STREAM_TIMEOUT_MINUTES),
        default: kit_1.Duration.minutes(consts.DEFAULT_STREAM_TIMEOUT_MINUTES)
    }),
    durationdays: command_1.flags.number({
        char: 'd',
        description: messages.getMessage('durationdaysFlagDescription', []),
        longDescription: messages.getMessage('durationdaysFlagLongDescription', []),
        required: false
    })
};

//# sourceMappingURL=create.js.map
