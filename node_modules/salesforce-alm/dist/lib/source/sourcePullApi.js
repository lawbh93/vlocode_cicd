"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
// 3pp
const BBPromise = require("bluebird");
const _ = require("lodash");
// Local
const mdapiRetrieveApi_1 = require("../mdapi/mdapiRetrieveApi");
const SourceUtil = require("./sourceUtil");
const ManifestCreateApi = require("./manifestCreateApi");
const SourceMetadataMemberRetrieveHelper = require("./sourceMetadataMemberRetrieveHelper");
const syncCommandHelper = require("./syncCommandHelper");
const messagesApi = require("../messages");
const MetadataRegistry = require("./metadataRegistry");
const bundleMetadataType_1 = require("./metadataTypeImpl/bundleMetadataType");
const pathUtil = require("./sourcePathUtil");
const sourceWorkspaceAdapter_1 = require("./sourceWorkspaceAdapter");
const aggregateSourceElements_1 = require("./aggregateSourceElements");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const srcStatusApi_1 = require("./srcStatusApi");
const MaxRevision_1 = require("./MaxRevision");
const util = require("util");
const sourceLocations_1 = require("./sourceLocations");
const path = require("path");
class MdapiPullApi extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.swa = options.adapter;
        if (this.swa) {
            this.smmHelper = new SourceMetadataMemberRetrieveHelper(this.swa);
        }
        this.scratchOrg = options.org;
        this.force = this.scratchOrg.force;
        this.messages = messagesApi(this.force.config.getLocale());
        this.obsoleteNames = [];
    }
    async init() {
        this.maxRevision = await MaxRevision_1.MaxRevision.getInstance({ username: this.scratchOrg.name });
        this.logger = await core_1.Logger.child(this.constructor.name);
        if (!this.swa) {
            const options = {
                org: this.scratchOrg,
                metadataRegistryImpl: MetadataRegistry,
                defaultPackagePath: this.force.getConfig().getAppConfig().defaultPackagePath
            };
            this.swa = await sourceWorkspaceAdapter_1.SourceWorkspaceAdapter.create(options);
            this.smmHelper = new SourceMetadataMemberRetrieveHelper(this.swa);
        }
    }
    async doPull(options) {
        // Remove this when pull has been modified to support the new mdapi wait functionality;
        if (isNaN(options.wait)) {
            options.wait = this.force.config.getConfigContent().defaultSrcWaitMinutes;
        }
        await this._checkForConflicts(options);
        const packages = await this.smmHelper.getRevisionsAsPackage(this.obsoleteNames);
        const results = await BBPromise.mapSeries(Object.keys(packages), async (pkgName) => {
            this.swa.packageInfoCache.setActivePackage(pkgName);
            const pkg = packages[pkgName];
            const opts = Object.assign({}, options);
            this.logger.debug('Retrieving', pkgName);
            try {
                // Create a temp directory
                opts.retrievetargetdir = await SourceUtil.createOutputDir('pull');
                // Create a manifest (package.xml).
                const manifestOptions = Object.assign({}, opts, {
                    outputdir: opts.retrievetargetdir
                });
                const manifest = await this._createPackageManifest(manifestOptions, pkg);
                this.logger.debug(util.inspect(manifest, { depth: 6 }));
                let result;
                if (manifest.empty) {
                    if (this.obsoleteNames.length > 0) {
                        result = { fileProperties: [], success: true, status: 'Succeeded' };
                    }
                }
                else {
                    // Get default metadata retrieve options
                    const retrieveOptions = Object.assign(mdapiRetrieveApi_1.MdRetrieveApi.getDefaultOptions(), {
                        retrievetargetdir: opts.retrievetargetdir,
                        unpackaged: manifest.file,
                        wait: opts.wait
                    });
                    // Retrieve the metadata
                    result = await new mdapiRetrieveApi_1.MdRetrieveApi(this.scratchOrg).retrieve(retrieveOptions).catch(err => err.result);
                }
                this.logger.debug(`Retrieve result:`, result);
                // Update local metadata source.
                return this._postRetrieve(result, opts);
            }
            finally {
                // Delete the output dir.
                await SourceUtil.cleanupOutputDir(opts.retrievetargetdir);
            }
        });
        // update the serverMaxRevision
        await this.maxRevision.setMaxRevisionCounterFromQuery();
        return results;
    }
    async _createPackageManifest(options, pkg) {
        if (pkg.isEmpty()) {
            return BBPromise.resolve({ empty: true });
        }
        if (_.isNil(options.packageXml) || !options.debug) {
            const configSourceApiVersion = this.force.getConfig().getAppConfig().sourceApiVersion;
            const sourceApiVersion = !_.isNil(configSourceApiVersion)
                ? configSourceApiVersion
                : this.force.getConfig().getApiVersion();
            pkg.setVersion(sourceApiVersion);
            return BBPromise.resolve(new ManifestCreateApi(this.force).createManifestForMdapiPackage(options, pkg, this.smmHelper.metadataRegistry));
        }
        else {
            return BBPromise.resolve({ file: options.packageXml });
        }
    }
    static _didRetrieveSucceed(result) {
        return (!_.isNil(result) &&
            result.success &&
            result.status === 'Succeeded' &&
            _.isNil(result.messages) &&
            !_.isNil(result.fileProperties) &&
            Array.isArray(result.fileProperties));
    }
    async _postRetrieve(result, options) {
        let changedSourceElements;
        let inboundFiles;
        if (MdapiPullApi._didRetrieveSucceed(result)) {
            changedSourceElements = await this._syncDownSource(result, options, this.swa);
            // NOTE: Even if no updates were made, we need to update source tracking for those elements
            // E.g., we pulled metadata but it's the same locally so it's not seen as a change.
            inboundFiles = changedSourceElements
                .getAllWorkspaceElements()
                .map(workspaceElement => workspaceElement.toObject());
            // WARNING
            // there exists a race condition here where between when we query / pull / write
            // to maxRevision.json - something could've changed on the server this change will appear on the next command
            // the metadata api should be updated to return RevisionCounter with each of the source members returned
            await sourceLocations_1.SourceLocations.nonDecomposedElementsIndex.maybeRefreshIndex(inboundFiles);
            await SourceUtil.getSourceMembersFromResult(inboundFiles, this.maxRevision);
            await this.maxRevision.updateSourceTracking();
        }
        return this._processResults(result, inboundFiles);
    }
    async _syncDownSource(result, options, swa) {
        const changedSourceElements = new aggregateSourceElements_1.AggregateSourceElements();
        // Each Aura bundle has a definition file that has one of the suffixes: .app, .cmp, .design, .evt, etc.
        // In order to associate each sub-component of an aura bundle (e.g. controller, style, etc.) with
        // its parent aura definition type, we must find its parent's file properties and pass those along
        // to processMdapiFileProperty.  Similarly, for other BundleMetadataTypes.
        const bundleFileProperties = bundleMetadataType_1.BundleMetadataType.getDefinitionProperties(result.fileProperties, this.swa.metadataRegistry);
        const postRetrieveHookInfo = {};
        result.fileProperties.forEach(fileProperty => {
            if (fileProperty.type === 'Package') {
                return;
            }
            // After retrieving, switch back to path separators (for Windows)
            fileProperty.fullName = pathUtil.replaceForwardSlashes(fileProperty.fullName);
            fileProperty.fileName = pathUtil.replaceForwardSlashes(fileProperty.fileName);
            this.swa.processMdapiFileProperty(changedSourceElements, options.retrievetargetdir, fileProperty, bundleFileProperties);
            postRetrieveHookInfo[fileProperty.fullName] = {
                mdapiFilePath: path.join(options.retrievetargetdir, fileProperty.fileName)
            };
        });
        // emit post retrieve event
        await core_1.Lifecycle.getInstance().emit('postretrieve', postRetrieveHookInfo);
        this.obsoleteNames.forEach(obsoleteName => {
            this.swa.handleObsoleteSource(changedSourceElements, obsoleteName.fullName, obsoleteName.type);
        });
        const sourcePromise = swa.updateSource(changedSourceElements, options.manifest, false /** check for duplicates **/, options.unsupportedMimeTypes, options.forceoverwrite);
        return sourcePromise
            .then(updatedSource => {
            // emit post source update event
            let postSourceUpdateHookInfo = {};
            updatedSource.forEach(sourceElementMap => {
                sourceElementMap.forEach(value => {
                    postSourceUpdateHookInfo[value.aggregateFullName] = {
                        workspaceElements: value.workspaceElements.map(workspaceElement => ({
                            fullName: workspaceElement['fullName'],
                            metadataName: workspaceElement['metadataName'],
                            sourcePath: workspaceElement['sourcePath'],
                            state: workspaceElement['state'],
                            deleteSupported: workspaceElement['deleteSupported']
                        }))
                    };
                });
            });
            core_1.Lifecycle.getInstance()
                .emit('postsourceupdate', postSourceUpdateHookInfo)
                .then(() => { });
        })
            .then(() => sourcePromise);
    }
    _processResults(result, inboundFiles) {
        if (_.isNil(result)) {
            return;
        }
        else if (MdapiPullApi._didRetrieveSucceed(result)) {
            return { inboundFiles };
        }
        else {
            const retrieveFailed = new Error(syncCommandHelper.getRetrieveFailureMessage(result, this.messages));
            retrieveFailed.name = 'RetrieveFailed';
            throw retrieveFailed;
        }
    }
    async _checkForConflicts(options) {
        if (options.forceoverwrite) {
            // do not check for conflicts when pull --forceoverwrite
            return [];
        }
        const statusApi = await srcStatusApi_1.SrcStatusApi.create({ org: this.scratchOrg, adapter: this.swa });
        return statusApi
            .doStatus({ local: true, remote: true }) // rely on status so that we centralize the logic
            .then(() => statusApi.getLocalConflicts())
            .catch(err => {
            let sfdxError = core_1.SfdxError.wrap(err);
            if (err.errorCode === 'INVALID_TYPE') {
                const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_pull');
                sfdxError.message = messages.getMessage('NonScratchOrgPull');
            }
            else if (err.errorCode === 'INVALID_SESSION_ID') {
                sfdxError.actions = [this.messages.getMessage('invalidInstanceUrlForAccessTokenAction')];
            }
            else {
                sfdxError.message = err.message;
            }
            throw sfdxError;
        })
            .then(conflicts => {
            if (conflicts.length > 0) {
                const error = new Error('Conflicts found during sync down');
                error['name'] = 'SourceConflict';
                error['sourceConflictElements'] = conflicts;
                throw error;
            }
        });
    }
}
exports.MdapiPullApi = MdapiPullApi;

//# sourceMappingURL=sourcePullApi.js.map
