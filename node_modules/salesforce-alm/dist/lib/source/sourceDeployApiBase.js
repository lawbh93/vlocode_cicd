"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const BBPromise = require("bluebird");
const replace = BBPromise.promisify(require('replace'));
const MdapiPollIntervalStrategy = require("../mdapi/mdapiPollIntervalStrategy");
const MdapiDeployApi = require("../mdapi/mdapiDeployApi");
const SourceConvertApi = require("./sourceConvertApi");
const srcDevUtil = require("../core/srcDevUtil");
const StashApi = require("../core/stash");
const sourceState = require("./sourceState");
const sourceUtil_1 = require("./sourceUtil");
const consts = require("../core/constants");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const { INSTANCE_URL_TOKEN } = consts;
const { sequentialExecute } = srcDevUtil;
class SourceDeployApiBase extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.orgApi = options.org;
        this.force = options.org.force;
        this.isAsync = !!options.isAsync;
    }
    async init() {
        this.logger = await core_1.Logger.child(this.constructor.name);
    }
    /**
     * Set additional required MDAPI options config and deploy
     * @param options The flags on the context passed to the command.
     * @param {any} pollIntervalStrategy The strategy for how often to poll when doing a MD deploy
     * @returns {any}
     */
    mdapiDeploy(options, pollIntervalStrategy) {
        // Default to disable mdapi logging.  Only when checkonly is explicitly true,
        // or testlevel is set, use the mdapi logging.
        options.disableLogging = !(options.checkonly === true || options.testlevel);
        options.autoUpdatePackage = false;
        options.testlevel = options.testlevel || 'NoTestRun';
        options.source = true;
        return new MdapiDeployApi(this.orgApi, pollIntervalStrategy, StashApi.Commands.SOURCE_DEPLOY).deploy(options);
    }
    /**
     * Set the state of the source elements that were deployed
     * @param aggregateSourceElements The map of source elements to deploy
     * @returns {any}
     */
    getOutboundFiles(aggregateSourceElements, isDelete = false) {
        let deployedSourceElements = [];
        aggregateSourceElements.getAllSourceElements().forEach(aggregateSourceElement => {
            deployedSourceElements = deployedSourceElements.concat(isDelete
                ? aggregateSourceElement.getWorkspaceElements().filter(el => el.getState() === sourceState.DELETED)
                : aggregateSourceElement.getWorkspaceElements());
        });
        return deployedSourceElements.map(workspaceElement => workspaceElement.toObject());
    }
    /**
     * Convert the SDFX-formatted source to MD-format and then deploy it to the org
     * @param options The flags on the context passed to the command.
     * @param sourceWorkspaceAdapter
     * @param aggregateSourceElements The map of source elements to deploy
     * @param {boolean} createDestructiveChanges Whether destructiveChanges.xml needs to be created for this deployment
     * @returns {any}
     */
    convertAndDeploy(options, sourceWorkspaceAdapter, aggregateSourceElements, createDestructiveChanges) {
        const sourceConvertApi = new SourceConvertApi(this.orgApi, sourceWorkspaceAdapter);
        return sourceConvertApi
            .convertSourceToMdapi(options.deploydir, null, aggregateSourceElements, createDestructiveChanges, options.unsupportedMimeTypes, options.delete)
            .then(([sourceElementsToUpsert, deletedTypeNamePairs]) => {
            // replace tokens embedded in source
            if (options.replacetokens) {
                return this.replaceTokens(options.deploydir).then(() => [sourceElementsToUpsert, deletedTypeNamePairs]);
            }
            return [sourceElementsToUpsert, deletedTypeNamePairs];
        })
            .then(([sourceElementsToUpsert, deletedTypeNamePairs]) => {
            let pollIntervalStrategy;
            // If checkonly or testlevel is set don't provide a poller or it will display
            // a status message from the mdapiDeploy logging on every poll.
            if (!(options.checkonly || options.testlevel || this.isAsync)) {
                pollIntervalStrategy = new MdapiPollIntervalStrategy(sourceElementsToUpsert, deletedTypeNamePairs);
            }
            return this.mdapiDeploy(options, pollIntervalStrategy);
        })
            .then(result => {
            // emit post deploy event
            return core_1.Lifecycle.getInstance()
                .emit('postdeploy', result)
                .then(() => result);
        })
            .catch(err => {
            if (err.name === 'mdapiDeployFailed') {
                return err.result;
            }
            throw err;
        });
    }
    /**
     * Remove source elements that failed to deploy
     * @param componentFailures
     * @param aggregateSourceElements
     */
    removeFailedAggregates(componentFailures, deployedSourceElements, packageInfoCache) {
        let failedSourcePaths = [];
        const failures = sourceUtil_1.toArray(componentFailures);
        failures.forEach(failure => {
            const key = `${failure.componentType}__${failure.fullName}`;
            const packageName = packageInfoCache.getPackageNameFromSourcePath(failure.fileName);
            const element = deployedSourceElements.getSourceElement(packageName, key);
            if (element) {
                element.getWorkspaceElements().forEach(element => {
                    failedSourcePaths = failedSourcePaths.concat(element.getSourcePath());
                });
                deployedSourceElements.deleteSourceElement(packageName, key);
            }
        });
    }
    /**
     * Some metadata types, such as RemoteSiteSetting, contain values specific to an org and need to be replaced
     * when the source is deployed to a new org
     * @param dir The directory where the metadata resides
     */
    replaceTokens(dir) {
        const replaceConfigs = [
            {
                regex: INSTANCE_URL_TOKEN,
                replacement: this.orgApi.authConfig.instanceUrl,
                paths: [dir],
                recursive: true,
                includes: ['*.remoteSite-meta.xml'],
                silent: true
            }
        ];
        const replaceFns = [];
        replaceConfigs.forEach(replaceConfig => {
            replaceFns.push(() => new BBPromise((resolve, reject) => {
                try {
                    replace(replaceConfig);
                    return resolve();
                }
                catch (err) {
                    return reject(err);
                }
            }));
        });
        return sequentialExecute(replaceFns);
    }
}
exports.SourceDeployApiBase = SourceDeployApiBase;

//# sourceMappingURL=sourceDeployApiBase.js.map
